<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>珍藏多年的学习资料300G+，全部免费赠送，从此离大神又近了一步</title>
    <link href="/2020/07/30/share01/"/>
    <url>/2020/07/30/share01/</url>
    
    <content type="html"><![CDATA[<h2 id="将时间线拉到2014"><a href="#将时间线拉到2014" class="headerlink" title="将时间线拉到2014"></a>将时间线拉到2014</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;2014年的寒冬，每天早晨六点钟，都会一个弱小的身影，从学校寝室出发，走在去实习公司的路上。经过食堂边的包子铺，他会顺手买两个包子，一杯豆浆，老板也会像往常一样热情的吆喝着回一句，”好勒同学，热乎乎的包子和豆浆，来，拿着，小心烫啊”。每次听到这里都会给那个寒冬里的他带来一丝暖意；他也会跟往常一样，匆匆的将手中的豆浆喝完，然后大步走向学校旁的公交车站台等候去往公司的车辆。因为坐车的时间早，所以经常整个公交车像是他的“专车”，偶尔也会因为天气冷，赖床等原因碰到上班早高峰，然后就开启着急赶车，下车狂跑，还没到公司就打开手机打卡(甚至抱怨定位为啥还打不上卡)，然后迟到，扣工资…一系列现在想起来觉得好笑又傻的行为，但就是这样开启了他的实习之路，从此也走向了“万劫不复”的深渊—攻城狮；<br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170839190-452495808.png" srcset="/img/loading.gif" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;其实对于一个实习生来说，最惨的还不是这些，应该是内心的煎熬吧，为什么会有煎熬？<br>Q：“这个需求怎么做，这么简单的问题如果问别人，会被嘲笑吧？”<br>Q：“这句代码怎么理解，还有这一句，这句和这句，wc，好像都不懂,怎么办？”<br>Q：“这个SQL语句怎么会有问题，怎么就是不行呢？”<br>Q：“这个框架怎么这么复杂，看了一个星期也没懂，有必要搞这么多层吗，一层不行吗？”<br>Q: “在我电脑上明明是好的啊，怎么在你这不行？”<br>Q：“额，为什么到点了大家都不下班？”<br>Q：“公司说晚上八点有免费晚餐，好开心啦，额，为什么其他人好像不咋么开心？”<br>Q：“这个代码没写好，看来今天一顿骂是在所难免的了”<br>…<br>…<br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170852910-893139923.png" srcset="/img/loading.gif" alt></p><p>这应该是大部分实习生的真实写照吧，反正我当年基本就是这心态，仔细想一下，除了社会阅历不足之外，更多的是能力上面的欠缺与其他有工作经验人之间产生了差距，导致内心的不自信，想做一件事，却做不好，甚至不知道如何动手去做，这种无力感真的很受煎熬，从那时候就开始明白，如果想要在这条路上走下去，必须有积累，不断的提升自己，才能减少与他人的差距</p><h2 id="厚积薄发"><a href="#厚积薄发" class="headerlink" title="厚积薄发"></a>厚积薄发</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;此后，还是那条路线，还是那一趟公交车，与以往不同的是，每天上下班再也不是无所事事了，各种编程教学视频，技术电子书，书籍都慢慢伴随着整个实习生涯，甚至是后面工作了，依然会有一些这样的习惯，下班回到宿舍，虽然很晚了，很累，但是白天的工作状态，不懂的地方，依然会在深夜去各种技术社区寻找答案，碰到好的技术资料学会自己存起来，收集起来，然后周末会跟寝室的同学一起学，一起讨论；犹记得那时候独爱看视频类的教程，因为跟着老师的思路一起走，一起写比较享受这样的过程，当然有的人会排斥这样学习方式，但是对于当时的自己来说，这样学校效果很快，学到的东西能用在工作上面，能不断的建立自信心，从而慢慢减少那种煎熬感，让能力得到不断的提升，甚至赶超其他人；<br>这里将所有收集到的学习资料全部免费分享给大家，包含但不仅限于(Asp.Net，Java，PHP，前端，Python，人工智能，Mysql，SQlServer，Redis等等)</p><h2 id="部分资料截图"><a href="#部分资料截图" class="headerlink" title="部分资料截图"></a>部分资料截图</h2><p><strong>asp.net教程系列</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170902645-2009247552.png" srcset="/img/loading.gif" alt></p><p><strong>SQlServer系列</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170914220-681305403.png" srcset="/img/loading.gif" alt></p><p><strong>mysql系列</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170921928-1766133748.png" srcset="/img/loading.gif" alt></p><p><strong>C++系列</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170932939-353745772.png" srcset="/img/loading.gif" alt></p><p><strong>python系列</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170939058-1428691240.png" srcset="/img/loading.gif" alt></p><p><strong>人工智能系列</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170946204-1796685943.png" srcset="/img/loading.gif" alt></p><p><strong>除了视频教程外，还准备了一些电子书籍</strong><br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730170955032-415674342.png" srcset="/img/loading.gif" alt></p><h2 id="彩蛋环节"><a href="#彩蛋环节" class="headerlink" title="彩蛋环节"></a>彩蛋环节</h2><p><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730171003315-12710210.png" srcset="/img/loading.gif" alt></p><p>之前在博客园看到过博客园大神“腾飞”的一遍文章，是关于他介绍自己学习英语的方法的，当时我也看到了，后面发现很多人评论像学习他的“暴力英语学习法”，所以，我这里也收集到大神学习英语的资料，<br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730171019063-1547206683.png" srcset="/img/loading.gif" alt><br>也一并分享给大家，全部拿走，不谢</p><h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><p>可以扫描下方二维码，关注公众号“DotNetCore开源学习”<br><strong>输入框内发送“111”</strong> ，<br>自动获取百度网盘分享链接<br><img src="https://img2020.cnblogs.com/blog/645287/202007/645287-20200730172357324-293537948.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>程序人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程学习</tag>
      
      <tag>视频教程</tag>
      
      <tag>电子书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务框架Demo.MicroServer运行手册</title>
    <link href="/2020/07/06/demomicroserver-use/"/>
    <url>/2020/07/06/demomicroserver-use/</url>
    
    <content type="html"><![CDATA[<h2 id="一-背景说明："><a href="#一-背景说明：" class="headerlink" title="一.背景说明："></a>一.背景说明：</h2><p>之前分享过一个微服务开发框架， “<a href="http://liuthing.com/2020/05/10/demomicroserver/">享一个集成.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo+SkyWalking的微服务开发框架</a>”，前两天在Github上收到一个Issues，是想我这边提供下完整的运行文档和配置文件，因为之前想法是弄清楚这几个东西的职责之后，对于运行的先后顺序，和需要的配置key应该都会有了解，所以README编写只是介绍了用到了哪些东西，没有说如何运行，但是既然有人问起，我还是满足一下，就当成是自己回顾了。</p><h2 id="二-回顾下项目结构"><a href="#二-回顾下项目结构" class="headerlink" title="二.回顾下项目结构"></a>二.回顾下项目结构</h2><p><img src="/images/demomicroserver-use/projectStruct.png" srcset="/img/loading.gif" alt="struct"><br>项目结构比较简单：</p><ul><li>MicroServer.Instance文件夹下面存放的是微服务实例，至于微服务颗粒度的拆分得结合实际的业务情况</li><li>Demo.MicroServer.IdentityServer4 统一鉴权中心</li><li>Demo.MicroServer.Infrastructure 基础设施，可以自行在里面添加内容</li><li>Demo.MicroServer.Ocelot  这一层是Api网关</li><li>Demo.MicroServer.Repository 通用的数据访问层，包含MySQL，Mongo，Redis等，之所以抽离出来，是方便各个服务实例可是直接使用这些通用方法。</li></ul><p>而上面说的 “.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo+SkyWalking” 中有几个东西还未出现，分别是 Consul，Polly，Exceptionless，Apollo，SkyWalking，这里还是分别介绍下</p><ul><li>Consul是一种服务网格解决方案，提供具有服务发现，健康检查，Key/Value存储，多数据中心等功能。在这里我们主要使用到服务发现，健康检查，启动场景是：微服务实例启动的时候</li><li>Polly是.NET弹性和瞬态故障处理库，与Ocelot天然友好集成，使用也只需要在Ocelot 层添加少数配置即可使用</li><li>Exceptionless是一款开源的实时的日志收集框架，可以使用在线或者本地搭建好的服务（如果只是本地测试建议直接使用在线的很方便），然后在微服务中配置好Url和应用的ApiKey就可以使用。</li><li>Apollo是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景，搭建好Apollo服务后，我们代码配置文件就可以变得相当干净了，只用留Apollo的配置就行，其他的配置几乎全部可以放在Apollo里面了。</li><li>SkyWalking 关于SkyWalking 我有一篇文章专门介绍了这个，这里不在赘述，需要了解的可以查看：<a href="http://liuthing.com/2020/05/16/skywalking/">在微服务框架Demo.MicroServer中添加SkyWalking+SkyApm-dotnet分布式链路追踪系统</a> </li></ul><h2 id="三-安装启动微服务周边应用"><a href="#三-安装启动微服务周边应用" class="headerlink" title="三.安装启动微服务周边应用"></a>三.安装启动微服务周边应用</h2><p>在运行服务之前，你或许可以先安装或开启以下几个服务</p><ol><li>MySql </li><li>Exceptionless<br> 如果还没安装可以参考：<a href="https://github.com/exceptionless/exceptionless/wiki/self-hosting" target="_blank" rel="noopener">https://github.com/exceptionless/exceptionless/wiki/self-hosting</a> ，建议使用docker安装</li><li>apollo<br> 如果还没安装，可以参考：<a href="https://github.com/ApolloAuto/apollo/blob/master/docs/quickstart/apollo_software_installation_guide_cn.md" target="_blank" rel="noopener">https://github.com/ApolloAuto/apollo/blob/master/docs/quickstart/apollo_software_installation_guide_cn.md</a></li><li>consul<br> 这个可以直接下载编译好的文件，直接启动就行<br> ./consul agent -dev -data-dir=/data/consul -node=agent-1 -client=0.0.0.0 -bind=10.34.5.101 -datacenter=demo</li><li>Skywalking<br> 请参考我之前的文章：<a href="http://liuthing.com/2020/05/16/skywalking/">在微服务框架Demo.MicroServer中添加SkyWalking+SkyApm-dotnet分布式链路追踪系统</a></li></ol><p>咋一看这么多需要安装启动的是不是感觉很慌？<br>不用担心，其实如果先排除身份验证连数据库都不用读，可以只用安装consul就可以，至于apollo可以先将配置写在代码的配置文件中，对于将项目跑起来这点来说apollo不是必须的，日志收集也可以暂缓，性能检测也一样，我们可以先将核心的跑起来，再来完善他的周边，秉着这个思路，我们开始运行</p><h2 id="四-开始启动"><a href="#四-开始启动" class="headerlink" title="四.开始启动"></a>四.开始启动</h2><ol><li><h3 id="启动consul"><a href="#启动consul" class="headerlink" title="启动consul"></a>启动consul</h3><p>开发下我们可以这样启动consul服务：</p><pre><code class="hljs routeros">./consul agent -dev <span class="hljs-attribute">-data-dir</span>=/data/consul <span class="hljs-attribute">-node</span>=agent-1 <span class="hljs-attribute">-client</span>=0.0.0.0 <span class="hljs-attribute">-bind</span>=10.34.5.101 <span class="hljs-attribute">-datacenter</span>=demo</code></pre><p>启动之后的效果如图：<br><img src="/images/demomicroserver-use/consul.png" srcset="/img/loading.gif" alt="consul"></p></li><li><h3 id="启动三个微服务实例"><a href="#启动三个微服务实例" class="headerlink" title="启动三个微服务实例"></a>启动三个微服务实例</h3><pre><code class="hljs reasonml">dotnet <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Demo</span>.</span><span class="hljs-module"><span class="hljs-identifier">MicroServer</span>.</span><span class="hljs-module"><span class="hljs-identifier">UserService</span>.</span></span>dll --urls=<span class="hljs-string">"http://*:6891"</span> --ip=<span class="hljs-string">"本机ip"</span> --port=<span class="hljs-number">6891</span>dotnet <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Demo</span>.</span><span class="hljs-module"><span class="hljs-identifier">MicroServer</span>.</span><span class="hljs-module"><span class="hljs-identifier">UserService</span>.</span></span>dll --urls=<span class="hljs-string">"http://*:6892"</span> --ip=<span class="hljs-string">"本机ip"</span> --port=<span class="hljs-number">6892</span>dotnet <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Demo</span>.</span><span class="hljs-module"><span class="hljs-identifier">MicroServer</span>.</span><span class="hljs-module"><span class="hljs-identifier">UserService</span>.</span></span>dll --urls=<span class="hljs-string">"http://*:6893"</span> --ip=<span class="hljs-string">"本机ip"</span> --port=<span class="hljs-number">6893</span></code></pre><p>这里演示，分别在6891，6892，6893三个端口启动用户的微服务实例，启动之后，consul就开始工作了，如图：<br><img src="/images/demomicroserver-use/consul_list.png" srcset="/img/loading.gif" alt="consul"></p></li></ol><p>而Consul是如何发现服务的，其实得益于我们在服务里面添加的一个扩展:</p><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IApplicationBuilder <span class="hljs-title">UseConsul</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IApplicationBuilder app, IConfiguration configuration</span>)</span><span class="hljs-function"></span>&#123;    ConsulClient _client = <span class="hljs-keyword">new</span> ConsulClient(c =&gt;    &#123;        c.Address = <span class="hljs-keyword">new</span> Uri(configuration[<span class="hljs-string">"Consul.ServerUrl"</span>]);        c.Datacenter = <span class="hljs-string">"Demo.MicroServer"</span>;    &#125;);    <span class="hljs-keyword">string</span> ip = configuration[<span class="hljs-string">"ip"</span>];    <span class="hljs-keyword">int</span> port = <span class="hljs-keyword">int</span>.Parse(configuration[<span class="hljs-string">"port"</span>]);    <span class="hljs-keyword">int</span> weight = <span class="hljs-keyword">string</span>.IsNullOrEmpty(configuration[<span class="hljs-string">"weight"</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-keyword">int</span>.Parse(configuration[<span class="hljs-string">"weight"</span>]);    _client.Agent.ServiceRegister(<span class="hljs-keyword">new</span> AgentServiceRegistration()    &#123;        ID = <span class="hljs-string">"UserService-"</span> + Guid.NewGuid(),        Name = <span class="hljs-string">"Demo.MicroServer.UserService"</span>,        Address = ip,        Port = port,        Tags = <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] &#123; <span class="hljs-keyword">string</span>.IsNullOrEmpty(configuration[<span class="hljs-string">"tags"</span>]) ? <span class="hljs-string">""</span> : configuration[<span class="hljs-string">"tags"</span>] &#125;,   <span class="hljs-comment">//标签</span>        Check = <span class="hljs-keyword">new</span> AgentServiceCheck()                                                                     <span class="hljs-comment">//健康检查</span>        &#123;            Interval = TimeSpan.FromSeconds(<span class="hljs-number">10</span>),                                                            <span class="hljs-comment">//每隔多久检测一次</span>            HTTP = <span class="hljs-string">$"http://<span class="hljs-subst">&#123;ip&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>/api/health/check"</span>,            Timeout = TimeSpan.FromSeconds(<span class="hljs-number">5</span>),            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="hljs-number">60</span>)                                       <span class="hljs-comment">//在遇到异常后关闭自身服务通道</span>        &#125;    &#125;);    <span class="hljs-keyword">return</span> app;&#125;</code></pre><p>并在StartUp.cs中使用了他：app.UseConsul(Configuration);</p><p>其实到这里，项目就已经跑起来了，并且具备初步的负载均衡功能，我们可以通过这三个端口其中任意一个来调用服务都是可以的。凡是都有但是，难道要人为去配置什么场景使用哪个ip和端口的服务吗，或者说要将我们所有的服务都暴露出去吗，每个服务都加一套登录鉴权机制吗？想想都觉得很可怕，那么怎么解决这个问题呢，答案就是.Net 中常用的APi GateWay之：Ocelot</p><ol start="3"><li><h3 id="启动网关Ocelot"><a href="#启动网关Ocelot" class="headerlink" title="启动网关Ocelot"></a>启动网关Ocelot</h3></li></ol><p>开始启动Ocelot层：dotnet Demo.MicroServer.Ocelot.dll<br>网关启动之后就可以通过网关的ip去访问任意被注册过的服务，前提是在网关层中有配置好协议，以下面两个为例子，一个是swagger，一个是用户服务</p><pre><code class="hljs actionscript"><span class="hljs-comment">//swagger</span>&#123;  <span class="hljs-string">"DownstreamPathTemplate"</span>: <span class="hljs-string">"/doc/Demo.MicroServer.UserService/swagger.json"</span>,  <span class="hljs-string">"DownstreamScheme"</span>: <span class="hljs-string">"http"</span>,  <span class="hljs-string">"ServiceName"</span>: <span class="hljs-string">"Demo.MicroServer.UserService"</span>,  <span class="hljs-string">"LoadBalancer"</span>: <span class="hljs-string">"RoundRobin"</span>,  <span class="hljs-string">"UseServiceDiscovery"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-string">"UpstreamPathTemplate"</span>: <span class="hljs-string">"/doc/Demo.MicroServer.UserService/swagger.json"</span>,  <span class="hljs-string">"UpstreamHttpMethod"</span>: [ <span class="hljs-string">"GET"</span>, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"DELETE"</span>, <span class="hljs-string">"PUT"</span> ]&#125;,<span class="hljs-comment">//UserService</span>&#123;  <span class="hljs-string">"DownstreamPathTemplate"</span>: <span class="hljs-string">"/api/&#123;url&#125;"</span>,  <span class="hljs-string">"DownstreamScheme"</span>: <span class="hljs-string">"http"</span>,  <span class="hljs-string">"UpstreamPathTemplate"</span>: <span class="hljs-string">"/api/&#123;url&#125;"</span>,  <span class="hljs-string">"UpstreamHttpMethod"</span>: [ <span class="hljs-string">"Get"</span>, <span class="hljs-string">"Post"</span>, <span class="hljs-string">"DELETE"</span>, <span class="hljs-string">"PUT"</span> ],  <span class="hljs-string">"ServiceName"</span>: <span class="hljs-string">"Demo.MicroServer.UserService"</span>,  <span class="hljs-string">"UseServiceDiscovery"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-string">"LoadBalancerOptions"</span>: &#123;    <span class="hljs-string">"Type"</span>: <span class="hljs-string">"RoundRobin"</span>&#125;,</code></pre><p>由于每个服务中都已经配置好了swagger文档，所以这里只需要指定路由协议，一样的可以通过网关来访问swagger<br>这里可以通过网关的ip和端口访问swagger和userservice服务</p><p>截止到这里服务的注册与发现还有网关的上下游配置基本完成，但是围绕在网关层的东西有很多，例如缓存，限流，熔断器，在网关层统一鉴权等等，但是这些不是当前要讨论的，这个具体根据后续反馈再看是否要单独拿出来解释.</p><h2 id="五-Apoll配置"><a href="#五-Apoll配置" class="headerlink" title="五.Apoll配置"></a>五.Apoll配置</h2><p>上面介绍了运行启动流程，根据需求，这里也贴一下apollo总的配置项，而网关层和用户服务层的配置在appsetting中有配置，代码中已经都有了，这里着重贴下apollo中的配置</p><ol><li><p>Demo.MicroServer.Ocelot 层在apollo中的配置:</p><pre><code class="hljs stylus">Swagger<span class="hljs-selector-class">.ServiceDocNames</span> = Demo<span class="hljs-selector-class">.MicroServer</span><span class="hljs-selector-class">.UserService</span>,Demo<span class="hljs-selector-class">.MicroServer</span>.ProductServiceIdentityService4<span class="hljs-selector-class">.Uri</span> = http:<span class="hljs-comment">//localhost:5000</span>IdentityService4<span class="hljs-selector-class">.UseHttps</span> = false</code></pre><p>如图：<br><img src="/images/demomicroserver-use/apollo_ocelot.png" srcset="/img/loading.gif" alt="apollo"></p></li><li><p>Demo.MicroServer.UserService 层在apollo中的配置:</p><pre><code class="hljs ini"><span class="hljs-attr">MySqlConnections</span> = server=mysql_ip<span class="hljs-comment">;port=3306;database=demo_microserver;User Id=root;pwd=123456;charset=utf8</span><span class="hljs-attr">Swagger.Name</span> = Demo.MicroServer.UserService<span class="hljs-attr">Swagger.Version</span> = v1<span class="hljs-attr">Swagger.DocName</span> = Demo.MicroServer.UserService<span class="hljs-attr">Swagger.Title</span> = Api interface documentation<span class="hljs-attr">Swagger.Description</span> = See below for specific interface<span class="hljs-attr">Swagger.Contact.Name</span> = PeyShine<span class="hljs-attr">Swagger.Contact.Email</span> = PeyShine@qq.COM<span class="hljs-attr">Swagger.XmlFile</span> = Demo.MicroServer.UserService.xml<span class="hljs-attr">Exceptionless.ApiKey</span> = LmqMIxSTW0U68pKwJ3xXqrNrLqS6oEociW7OexNt<span class="hljs-attr">Exceptionless.ServerUrl</span> = http://exceptionless_ip:<span class="hljs-number">5000</span><span class="hljs-attr">Consul.ServerUrl</span> = http://consul_ip:<span class="hljs-number">8500</span><span class="hljs-attr">MongoDB.DefaultConnection</span> = mongodb://dev:Aa123456@mongo_ip/demo_db<span class="hljs-attr">MongoDB.DefaultDatabase</span> = demo_db<span class="hljs-attr">MongoDB.DefaultTable</span> = users</code></pre><p>如图:<br><img src="/images/demomicroserver-use/apollo_userservice.png" srcset="/img/loading.gif" alt="apollo"></p></li></ol><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h2><p>本文作为文章”<a href="http://liuthing.com/2020/05/10/demomicroserver/">分享一个集成.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo+SkyWalking的微服务开发框架</a>“的一个补充扩展，主要是介绍如何一步步启动Demo.MicroServer微服务框架，里面关于网关还有IdentityServer4没有进行深入讨论，想法是只要能先将项目核心部分跑起来，周边应用可以自行添加，后续再根据反馈是否要更加详细的去介绍。<br>其实理解了几个开源项目自己的职责之后，对运行流程就不难理解了，动手试试吧!</p><p>文章代码在Github中的地址：<a href="https://github.com/PeyShine/Demo.MicroServer" target="_blank" rel="noopener">https://github.com/PeyShine/Demo.MicroServer</a>,欢迎star</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>.NetCore</tag>
      
      <tag>Swagger</tag>
      
      <tag>Consul</tag>
      
      <tag>Polly</tag>
      
      <tag>Ocelot</tag>
      
      <tag>IdentityServer4</tag>
      
      <tag>Exceptionless</tag>
      
      <tag>Apollo</tag>
      
      <tag>SkyWalking</tag>
      
      <tag>SkyWalking-dotnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三)</title>
    <link href="/2020/07/01/hexo03/"/>
    <url>/2020/07/01/hexo03/</url>
    
    <content type="html"><![CDATA[<h3 id="Hexo目录："><a href="#Hexo目录：" class="headerlink" title="Hexo目录："></a>Hexo目录：</h3><p><a href="http://liuthing.com/2020/06/15/hexo01/">Hexo快速构建个人小站-Hexo初始化和将项目托管在Github(一)</a><br><a href="http://liuthing.com/2020/06/17/hexo02/">Hexo快速构建个人小站-自定义域名和自定义主题(二)</a></p><h3 id="背景交代："><a href="#背景交代：" class="headerlink" title="背景交代："></a>背景交代：</h3><p>前面两章完成了Hexo的初始化和部分自定义的功能，对于只想展示文章来说也是没有问题的，但是无法与读者进行互动，无论读者对错误的反馈还是对优质内容的鼓励这些统统都不知道，所以我们先给文章加上评论系统，让读者有渠道可以反馈，也让作者对于反馈有一个好的总结，优化改善，循序渐进才能将博客建设的更好。<br>至于评论系统的选择有很多，available | disqus | valine | gitalk | utterances | changyan | livere，而我使用的是Fluid主题，主题推荐使用Valine或者Utterances，然后结合了下网上对这几款评论系统的凭借之后，果断选取了Valine（就是这么随便）</p><p>Valine的特点：</p><ul><li>无后端实现</li><li>高速，使用国内后端云服务提供商 LeanCloud 提供的存储服务</li><li>开源，自定义程度高</li><li>支持邮件通知</li><li>支持验证码</li><li>支持 Markdown</li></ul><h3 id="一：注册Leancloud"><a href="#一：注册Leancloud" class="headerlink" title="一：注册Leancloud"></a>一：注册Leancloud</h3><p>Valine作为一款第三方的评论系统，评论数据都储存在Leancloud上，所以第一步我们要去 leancloud官网：<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">https://www.leancloud.cn/</a> 注册一个账户，注册完成后现在需要实名认证后才可以创建应用，<br><img src="/images/hexo03/1.png" srcset="/img/loading.gif" alt="1"></p><h3 id="二：Leancloud上创建应用"><a href="#二：Leancloud上创建应用" class="headerlink" title="二：Leancloud上创建应用"></a>二：Leancloud上创建应用</h3><p><img src="/images/hexo03/2.png" srcset="/img/loading.gif" alt="2"></p><p>创建完成之后在页面会出现一个如下图所示的项目:<br><img src="/images/hexo03/3.png" srcset="/img/loading.gif" alt="3"></p><p>然后在应用-》设置-》应用keys下面可以看到几个我们所需要的的核心信息数据:<br><img src="/images/hexo03/4.png" srcset="/img/loading.gif" alt="4"></p><p>为了数据安全，在配置一下Web安全域名<br><img src="/images/hexo03/5.png" srcset="/img/loading.gif" alt="5"></p><h3 id="三：配置主题下的-config-yml"><a href="#三：配置主题下的-config-yml" class="headerlink" title="三：配置主题下的_config.yml"></a>三：配置主题下的_config.yml</h3><p>在目录 thems/fluid/_config.yml 下修改相关信息。第一步是开启评论</p><pre><code class="hljs yaml"><span class="hljs-attr">comments:</span>  <span class="hljs-comment"># 评论</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启评论</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span>  <span class="hljs-comment"># 指定使用的评论模块</span></code></pre><p>第二步填写应用Keys相关信息</p><pre><code class="hljs yaml"><span class="hljs-comment"># Valine</span><span class="hljs-comment"># 完整文档 https://valine.js.org/configuration.html</span><span class="hljs-comment"># 注意：下列配置项中的 true/false 不要用引号括起来</span><span class="hljs-attr">valine:</span>  <span class="hljs-attr">appid:</span>  <span class="hljs-comment"># 从 LeanCloud 的应用中得到的 appId</span>  <span class="hljs-attr">appkey:</span>  <span class="hljs-comment"># 从 LeanCloud 的应用中得到的 APP Key</span>  <span class="hljs-attr">placeholder:</span> <span class="hljs-string">吐槽</span> <span class="hljs-comment"># 评论框占位提示符</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span> <span class="hljs-comment"># 当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表</span>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">retro</span> <span class="hljs-comment"># Gravatar 头像展示方式</span>  <span class="hljs-attr">meta:</span> <span class="hljs-string">['nick',</span> <span class="hljs-string">'mail'</span><span class="hljs-string">,</span> <span class="hljs-string">'link'</span><span class="hljs-string">]</span>  <span class="hljs-comment"># 评论者相关属性</span>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 评论列表分页，每页条数</span>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment"># zh-CN | zh-TW | en | ja</span>  <span class="hljs-attr">highlight:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 代码高亮</span>  <span class="hljs-attr">recordIP:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否记录评论者IP</span>  <span class="hljs-attr">serverURLs:</span>  <span class="hljs-comment"># REST API 服务器地址，国际版不填</span></code></pre><p>配置完成之后可以重启hexo</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">s</span></code></pre><h3 id="四：查看效果"><a href="#四：查看效果" class="headerlink" title="四：查看效果"></a>四：查看效果</h3><p><img src="/images/hexo03/6.png" srcset="/img/loading.gif" alt="6"></p><p>来评论下试试：<br><img src="/images/hexo03/7.png" srcset="/img/loading.gif" alt="7"></p><p>可以看到，评论成功了。整个过程比较简单，动手试试吧！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo构建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>评论系统</tag>
      
      <tag>Valine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo快速构建个人小站-自定义域名和自定义主题(二)</title>
    <link href="/2020/06/17/hexo02/"/>
    <url>/2020/06/17/hexo02/</url>
    
    <content type="html"><![CDATA[<h3 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h3><p>在上一章《Hexo快速构建个人小站-Hexo初始化和将项目托管在Github(一)》中，我们已经成功的利用hexo初始化了博客项目，并托管在Github上，且通过Github的二级域名可以成功访问，但是，这么长的域名总归是是有点别扭，如果有强迫症估计更是受不了，这节我们介绍绑定自定义域名和配置自己喜欢的主题。</p><h3 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h3><p>自定义域名第一步：挑选好一个自己喜欢的域名并购买，域名服务商可以在阿里云旗下的万网或者腾讯云都可以，由于我之前就在阿里云买了一个域名：liuthing.com，没有使用，所以现在就用上了<br><img src="/images/hexo02/1.png" srcset="/img/loading.gif" alt="1"><br>买完之后在阿里云控制台域名下面就会展示出购买的域名信息</p><h3 id="2-解析域名"><a href="#2-解析域名" class="headerlink" title="2.解析域名"></a>2.解析域名</h3><p>开始做域名解析工作，解析之前先ping 一下Github下博客仓库对应的二级域名：username.github.io的ip地址<br>我这里ping完后得到的ip是：185.199.109.153<br>然后做两个解析，如图：<br><img src="/images/hexo02/2.png" srcset="/img/loading.gif" alt="2"><br><img src="/images/hexo02/3.png" srcset="/img/loading.gif" alt="3"><br><img src="/images/hexo02/4.png" srcset="/img/loading.gif" alt="4"></p><h3 id="3-设置CNAME"><a href="#3-设置CNAME" class="headerlink" title="3.设置CNAME"></a>3.设置CNAME</h3><p>在项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），填写上域名。比如：<br><img src="/images/hexo02/5.png" srcset="/img/loading.gif" alt="5"></p><h3 id="4-发布项目"><a href="#4-发布项目" class="headerlink" title="4.发布项目"></a>4.发布项目</h3><p><img src="/images/hexo02/6.png" srcset="/img/loading.gif" alt="6"></p><h3 id="5-用自定义的域名访问"><a href="#5-用自定义的域名访问" class="headerlink" title="5.用自定义的域名访问"></a>5.用自定义的域名访问</h3><p>完成上述步骤之后就可以在浏览器输入自己的域名访问了<br><img src="/images/hexo02/7.png" srcset="/img/loading.gif" alt="7"></p><h3 id="6-找一款自己喜欢的主题"><a href="#6-找一款自己喜欢的主题" class="headerlink" title="6.找一款自己喜欢的主题"></a>6.找一款自己喜欢的主题</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> ,这个里面有很多主题，可以任意挑选一个自己喜欢的主题，点击进去，通常都有github地址，上面有安装和使用方法介绍，我这里选了一个名叫“fluid” 的主题。<br>这是使用地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">https://github.com/fluid-dev/hexo-theme-fluid</a><br>下面截图是fluid使用介绍的部分内容<br><img src="/images/hexo02/8.png" srcset="/img/loading.gif" alt="8"></p><p>按照要求，只需两步即可，将主题下载下来，然后指定主题，然后运行在本地查看效果<br><img src="/images/hexo02/9.png" srcset="/img/loading.gif" alt="9"><br>可以看到已经实现自定义主题了，主题这里还有很多可以自己设置的地方，下回再继续分解，动手试试吧！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo构建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>自定义主题</tag>
      
      <tag>自定义域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo快速构建个人小站-Hexo初始化和将项目托管在Github(一)</title>
    <link href="/2020/06/15/hexo01/"/>
    <url>/2020/06/15/hexo01/</url>
    
    <content type="html"><![CDATA[<h2 id="背景交代"><a href="#背景交代" class="headerlink" title="背景交代"></a>背景交代</h2><p>相信每个程序员都有自己做过个人网站,博客之类的项目了，但是现在还在维护吗？反正我前前后后做过2到3个了，维护一段时间后因为一些不可逆的原因(主要是懒)都没有维护了，购买的一些域名和服务器信息也都过期了，最近玩了一下hexo，发现这个东西挺方便的，基本半个小时就可以搞完，并且如果 完全托管在github上基本就是0成本，用作学习记录输出是够了。</p><h3 id="1-依赖于nodejs安装，安装nodejs和npm"><a href="#1-依赖于nodejs安装，安装nodejs和npm" class="headerlink" title="1.依赖于nodejs安装，安装nodejs和npm"></a>1.依赖于nodejs安装，安装nodejs和npm</h3><p>下载地址，可以对照电脑系统版本进行下载安装：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a><br>现在nodejs的安装包内置了npm，所以下载安装完成之后，nodejs和npm都会安装好</p><p>检查安装是否成功<br><img src="/images/hexo01/1.png" srcset="/img/loading.gif" alt="1"><br>安装成后会显示出对应的版本信息，由于我电脑之前就安装过了，所以应该不是最新的版本</p><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>安装命令：</p><pre><code class="hljs bash">$ sudo npm i -g hexo</code></pre><p><img src="/images/hexo01/2.png" srcset="/img/loading.gif" alt="2"><br>直接一步就安装完成了,然后可以通过hexo -v查看是否安装成，成功安装的话，会打印出上面截图中的一些版本信息</p><h3 id="3-hexo初始化博客项目"><a href="#3-hexo初始化博客项目" class="headerlink" title="3.hexo初始化博客项目"></a>3.hexo初始化博客项目</h3><p>命令：</p><pre><code class="hljs bash">$ hexo init</code></pre><p><img src="/images/hexo01/3.png" srcset="/img/loading.gif" alt="3"><br>初始化完成之后，看看hexo在文件夹给我生成了哪些文件<br><img src="/images/hexo01/4.png" srcset="/img/loading.gif" alt="4"><br>如果你是一名前端或者nodejs开发者，相信对这些文件再熟悉不过了，还是对上述几个文件简单解释一下：<br>node_modules：存放依赖包信息<br>public：存放生成的页面<br>scaffolds：存放生成文章的一些模板<br>source：存放用命令创建的各种文章<br>themes：存放博客使用的主题<br>_config.yml：存放整个博客的配置<br>db.json：存放source解析所得到的<br>package.json：存放项目所需模块项目的配置信息</p><h3 id="4-将生成的博客项目跑起来"><a href="#4-将生成的博客项目跑起来" class="headerlink" title="4.将生成的博客项目跑起来"></a>4.将生成的博客项目跑起来</h3><pre><code class="hljs bash">1、清除hexo clean2、生成hexo g3、启动服务hexo server</code></pre><p><img src="/images/hexo01/5.png" srcset="/img/loading.gif" alt="5"><br>启动完成后就可以按照提示，打开  <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>  来访问我们在本地初始化好的博客项目了<br><img src="/images/hexo01/6.png" srcset="/img/loading.gif" alt="6"><br>可以看到我们的项目已经成功跑起来了，成功的迈出了第一步，先暂且按耐住激动的心情，我们继续！</p><h3 id="5-在GitHub上创建仓库用于托管博客项目"><a href="#5-在GitHub上创建仓库用于托管博客项目" class="headerlink" title="5.在GitHub上创建仓库用于托管博客项目"></a>5.在GitHub上创建仓库用于托管博客项目</h3><p><img src="/images/hexo01/7.png" srcset="/img/loading.gif" alt="7"><br>仓库名称需要配置为：个人名字.github.io，仓库设置为公开，然后点击创建就可以</p><h3 id="6-配置-config-yml"><a href="#6-配置-config-yml" class="headerlink" title="6.配置_config.yml"></a>6.配置_config.yml</h3><pre><code class="hljs bash">deploy:   <span class="hljs-built_in">type</span>: git   repository: https://github.com/PeyShine/PeyShine.github.io.git   branch: master</code></pre><h3 id="7-上传项目"><a href="#7-上传项目" class="headerlink" title="7.上传项目"></a>7.上传项目</h3><p>在此之前请先安装一个插件</p><pre><code class="hljs bash">npm install hexo-deployer-git --save</code></pre><p>部署（上传到GitHub）</p><pre><code class="hljs bash">hexo d 或者 hexo deploy</code></pre><p><img src="/images/hexo01/8.png" srcset="/img/loading.gif" alt="8"><br>上传过程中输入了用户名和密码，如果提前配置好ssh也可以不用输入</p><p>到Github上看一下，是否上传成功<br><img src="/images/hexo01/9.png" srcset="/img/loading.gif" alt="9"></p><p>可以看到文件都已经上传成功了</p><h3 id="8-成功访问"><a href="#8-成功访问" class="headerlink" title="8.成功访问"></a>8.成功访问</h3><p>通过域名“peyshine.github.io” 来访问<br><img src="/images/hexo01/10.png" srcset="/img/loading.gif" alt="10"></p>]]></content>
    
    
    <categories>
      
      <category>Hexo构建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从一年前的1200多人优化到现在200多人，待在这样的技术团队是一种什么体验？</title>
    <link href="/2020/06/03/hqteam/"/>
    <url>/2020/06/03/hqteam/</url>
    
    <content type="html"><![CDATA[<h2 id="1-写点情怀"><a href="#1-写点情怀" class="headerlink" title="1.写点情怀"></a>1.写点情怀</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;平日里都是分享技术的，但是最近做的最多的一件事却是送别，挺悲伤的一个词，我个人不太喜欢，但是现在整个大的环境都不太景气，众多企业纷纷倒闭，一批批工人，白领被迫失去了工作，其中也不乏我自己所在的职业：程序员。特别的从去年年底至今，依旧活着的公司大部分也是苟延残喘，大幅度的“优化”员工，而我自己身边的朋友，送走了一批又一批，自己的感触挺深的，所以想把这段时间的经历写成文字，当做是解压了。</p><h2 id="2-亲身经历"><a href="#2-亲身经历" class="headerlink" title="2.亲身经历"></a>2.亲身经历</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在现在这家公司干了接近三年了，刚进来时，整个IT部分是700多人，当时业务发展速度很快，很多业务线需要技术做数据支撑，那时公司处在上升期，所以不断的在扩张技术团队去满足各种业务需求，顶峰时期，技术团队达到了1200多人，各种项目也是琳琅满目(姑且这样形容吧，算是对好的一种向往)，自己也有参与到不同的项目中，也学到了挺多东西，交到了很多朋友，乐此不疲。但是好景不长，伴随着互联网寒冬以及疫情的到来，从去年年底到现在，身边很多朋友陆陆续续都离开了，举一个印象比较深刻的例子：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;去年五月份开始，我们领导找我组建一个新的项目团队，做3D应用相关的开发，当时结合了公司的业务和市场反馈，经过简短沟通后说干就干，然后就开始对相关技术做调研(因为在这之前完全没做过3D应用的开发)，刚开始只招聘了一个技术，之前有做过相关工作，来了之后形成了一个三人小组，开始做硬件选型，做竞品分析(当然也在学习别人的优势)，做关键技术的攻克，两个月后领导拿着我们费了九年二虎之力的一个demo去找老总，估计就是一顿前(连)景(哄)展(带)示(骗)了，项目被公司看好，觉得可以投入人力和更多的资源，将其形成真正的产品。然后就开始招聘技术，产品，3D建模师，UI设计师等等搭建技术团队，到9月份形成了一个9人组成的项目小组开始立项，走产品化流程，从一个demo到真正形成一个产品确实也需要走很多路，由于应用较为特殊，我们从硬件开始准备，期间用到的技术栈(包含但又不仅仅是):电机，树莓派，Python，Nodejs，.NetCore，Unity3D，Aws众多云服务(MySQL,Redis,SQS,负载均衡器,CDN,S3,EC2等等)，过程可以用过五关斩六将来形容，解决了很多技术上的难点，也做了一些以前没有做过的尝试，直到12月份项目上线可第一个版本，大家都觉得松了一口气，毕竟过程虽然很波折，但是大家都很充实，一起撸代码，一起加班，一起解决困难，一起喝下午茶，一起打闹，有时会为一个问题争执不休而闹情绪，有时也会因为一点点小的突破而哈哈大笑，确实留下了很多珍贵的回忆。上线后也收到了很多反馈，后续也在对线上版本进行不断的迭代优化，从上线到过年一个多月的时间里，一直频繁的在发版本，虽然大家都觉得被各方大佬孽的很惨，但是依然干劲十足。年后由于疫情，大家都开始在家远程办公，但是面对一次次的延迟上班的通知，大家可能心里多少都有些想法，但是该来的总会来，远程办公的第二周，领导就通知说，现在疫情给公司带来了较大的影响，为了维护公司的正常运转只保留核心技术团队，而我们刚上线两个多月的项目也被迫就此夭折。而我也亲自参与到了项目的下线整个过程，心里很不是滋味，毕竟就像是十月怀胎后刚出生的婴儿，还希望它能健康长大的，但是深深的明白，在职场没有人会去谈这些感情感性的东西，都是以结果，收益为导向。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;项目被砍了，人员自然也是公司关注的焦点，各种名义开始大幅度的优化人员，而我所在的项目组，除了我和我领导两个人转到了另外一个团队，其他所有的小伙伴都开始了离开的行程，收到了很多工作交接，送他们一个个的离开，这种场景虽然嘴上会说没关系，走到哪里都是朋友，但是内心里多少还是有点不舒服，毕竟一起留下了诸多回忆，难免会有所伤感。而这个例子只是N多个项目小组的一个缩影，由于在公司做过很多项目，认识的人也不少，最近收到他们的消息，陆陆续续的都离开了，再放眼望去，三年在技术团队认识的一些人现在依然在的，寥寥无几了，也是最触动自己的地方。</p><h2 id="3-大环境不好，怎么破局？"><a href="#3-大环境不好，怎么破局？" class="headerlink" title="3.大环境不好，怎么破局？"></a>3.大环境不好，怎么破局？</h2><ol><li><p>不管程序员是不是吃青春饭，相对其他行业来说，程序员的薪资还是有优势的，就我们公司，开发年薪50W的不在少数，由开发上升为管理岗的年薪过100W的也是存在的，哪怕是青春饭，那么是否能在有限的时间里面提升自己，让自己更有价值，也能为以后打下好的基础。</p></li><li><p>互联网更新迭代的速度是很快的，几年就会兴起一股潮流趋势，一会人工智能，一会区块链，一会中台等等，很多开发者会去追随这些比较流行的物种，当然了解前沿知识是好事，但是不在少数的开发者会盲目的去跟风，一会做前端，一会做后端，一会小程序，一会人工智能，各种技术栈说起来都会，都用过，但是不精，知其然，不知其所以然。并不是说了解这些东西不好，只是我们要有个度，不能盲目，一味追随可能让自己浮躁，忽略了知识体系的积累，从而使自己失去了核心竞争力。</p></li><li><p>之前面试我自己有个习惯，在结束时一般面试官会问自己有没有什么是想了解的，这个时候我通常会问：咱们公司的核心竞争力是什么？其实这句话用在我们自己身上也很合适，我们自己的核心竞争力，优势又是什么呢。我觉得很重要的一点就是不断学习，快速成长，只有当我们自己保持一个较快的成长速度，那就可以跟别人拉开差距，并持续将差距最大化，这样我们才能在竞争中保证自身的优势，最差也能立于不败之地。</p></li><li><p>如果你现在的工作很安逸，通常都不是什么好事，这意味着一切按部就班，然后慢慢在消耗我们的上进心和斗志，扼杀我们的创造力，这也是经常大家都懂的温水煮了青蛙的道理；同时也意味着我们慢慢失去了竞争力，也会因为太安逸，让我们变得胆怯，以至于在遇到更好的机会时，我们会犹豫不决… 职场上得懂得居安思危</p></li></ol><h2 id="4-共勉"><a href="#4-共勉" class="headerlink" title="4.共勉"></a>4.共勉</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;希望所有的程序员们也包括自己，做一个有担当，有理想，有抱负的好青年，带着写程序的初心，从“hello world”写到”change the world”，一起加油吧！</p>]]></content>
    
    
    <categories>
      
      <category>程序人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IT团队</tag>
      
      <tag>优化</tag>
      
      <tag>破局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile+Jenkinsfile+GitLab轻松实现.NetCore程序的CI&amp;CD</title>
    <link href="/2020/05/26/cicd/"/>
    <url>/2020/05/26/cicd/</url>
    
    <content type="html"><![CDATA[<h2 id="一-相关介绍"><a href="#一-相关介绍" class="headerlink" title="一.相关介绍"></a>一.相关介绍</h2><ol><li><p>Dockerfile：关于Dockerfile的使用说明，我在文章《让.NetCore程序跑在任何有docker的地方》中有说到，这里不在赘述，需要的可以先看下，本文主要介绍Jenkinsfile结合dockerfile配合使用，自动构建.NetCore应用程序。</p></li><li><p>Jenkinsfile ：Jenkinsfile 是 Jenkins 2.x 或更高版本核心特性 Pipeline（流水线） 的脚本，或者说对于Jenkins 流水线的定义被写在一个叫Jenkinsfile的文本文件中，该文件可以被提交到项目的源代码的控制仓库。这是”流水线即代码”的基础; 将CD 流水线作为应用程序的一部分，像其他代码一样进行版本化和审查。 创建 <code>Jenkinsfile</code>并提交它到源代码控制中提供了以下几个好处:</p><ul><li>自动地为所有分支创建流水线构建过程并拉取请求。</li><li>在流水线上代码复查/迭代 (以及剩余的源代码)。</li><li>对流水线进行审计跟踪。</li><li>该流水线的真正的源代码 , 可以被项目的多个成员查看和编辑。</li></ul></li></ol><p>Jenkinsfile 能使用两种语法进行编写，分别是“声明式”和“脚本化”，二者语法都是 DSL(Domain-specific language) 语言，二者语法差不多，下面我们具体看下</p><h2 id="二-Jenkins和GitLab的安装"><a href="#二-Jenkins和GitLab的安装" class="headerlink" title="二.Jenkins和GitLab的安装"></a>二.Jenkins和GitLab的安装</h2><p>工欲善其事，必先利其器<br>Jenkins的安装可以看我之前的一篇文章：<a href="https://www.cnblogs.com/peyshine/p/12891935.html" target="_blank" rel="noopener">https://www.cnblogs.com/peyshine/p/12891935.html</a><br>Gitlab的安装推荐看下这篇文章：<a href="https://segmentfault.com/a/1190000021593151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021593151</a></p><h2 id="三-打通GitLab-Webhooks与Jenkins流程"><a href="#三-打通GitLab-Webhooks与Jenkins流程" class="headerlink" title="三.打通GitLab Webhooks与Jenkins流程"></a>三.打通GitLab Webhooks与Jenkins流程</h2><ol><li>这里先新建一个.net core应用程序，除了新增加了一个Jenkinsfile文件以外，其他没有任何代码的修改<br><img src="/images/cicd/1.png" srcset="/img/loading.gif" alt="1"></li></ol><p><strong>注意，Jenkinsfile的J需要大写，我测试了，小写会提示找不到文件.</strong><br>Jenkinsfile中添加了几行测试代码：</p><pre><code class="hljs sqf">pipeline&#123;    <span class="hljs-built_in">agent</span> any    stages &#123;        stage(<span class="hljs-string">'Build'</span>) &#123;            steps&#123;                <span class="hljs-built_in">echo</span> <span class="hljs-string">'This is a build step'</span>             &#125;        &#125;        stage(<span class="hljs-string">'Test'</span>) &#123;            steps&#123;                <span class="hljs-built_in">echo</span> <span class="hljs-string">'This is a test step'</span>              &#125;        &#125;        stage(<span class="hljs-string">'Deploy'</span>) &#123;            steps&#123;                <span class="hljs-built_in">echo</span> <span class="hljs-string">'This is a deploy step'</span>                &#125;        &#125;    &#125;&#125;</code></pre><p>然后将程序文件push到Gitlab上</p><ol start="2"><li><p>在Jenkins系统管理，系统配置中，在Gitlab处添加相关信息<br><img src="/images/cicd/2.png" srcset="/img/loading.gif" alt="2"><br><img src="/images/cicd/3.png" srcset="/img/loading.gif" alt="3"><br>下面点击添加凭据，类型选择GitLab Api Token，由于这个Token需要由GitLab来提供，所以先到GitLab生成一个Api Token</p></li><li><p>生成Api Token<br><img src="/images/cicd/4.png" srcset="/img/loading.gif" alt="4"><br><img src="/images/cicd/5.png" srcset="/img/loading.gif" alt="5"></p></li></ol><p>点击创建之后，Token就生效了<br>将Api Token复制到Jenkins中，点击添加<br><img src="/images/cicd/6.png" srcset="/img/loading.gif" alt="6"></p><p>添加完成后，就可以在Credentials中选择刚刚添加好的凭据<br><img src="/images/cicd/7.png" srcset="/img/loading.gif" alt="7"><br>点击保存，这样系统配置中的Gitlab的全局配置就生效了</p><ol start="4"><li>新建流水线任务测试<br>下面打开Jenkins，新建一个流水线发布任务，取名test，然后点击确定.<br><img src="/images/cicd/8.png" srcset="/img/loading.gif" alt="8"></li></ol><p>勾选构建触发器<br><img src="/images/cicd/9.png" srcset="/img/loading.gif" alt="9"></p><p>由于我们需要达到的目的是在GitLab提交代码，Jenkins可以自动构建相关任务，所以我们还需要配置一个触发器。如图，点击下面的”高级”按钮<br><img src="/images/cicd/10.png" srcset="/img/loading.gif" alt="10"></p><p>点击“Generate”，生成一个SecretToken<br><img src="/images/cicd/10.1.png" srcset="/img/loading.gif" alt="10.1"></p><p>然后再流水线Tab定义处，下拉选择“Pipeline script from SCM”，SCM选择Git，然后填写代码库的地址和访问用户密码，下面脚本路径有个Jenkinsfile，意思就是从我们提交到源代码管理根目录下面的Jenkinsfile中读取相关定义好的的流水线任务流程<br><img src="/images/cicd/11.png" srcset="/img/loading.gif" alt="11"><br>点击保存</p><p>在Gitlab如下图地方进入，来配置web钩子<br><img src="/images/cicd/12.png" srcset="/img/loading.gif" alt="12"><br><img src="/images/cicd/15.png" srcset="/img/loading.gif" alt="15"><br>将在Jenkin中截图的一个url和生成的token分别填写在下方，在触发器的地方勾选上 Push events，然后点击下方的“Add webhook” 按钮。如果你还有其他事件发生时想触发Jenkins的任务，也可以自行勾选上</p><p><img src="/images/cicd/16.png" srcset="/img/loading.gif" alt="16"><br>添加完成后点击测试<br><img src="/images/cicd/17.png" srcset="/img/loading.gif" alt="17"></p><p>这个时候可以看到上方出现了成功的提示<br><img src="/images/cicd/18.png" srcset="/img/loading.gif" alt="18"></p><p>而另一边Jenkins中，正在执行任务，并且任务的执行是 GitLab有推送任务<br><img src="/images/cicd/19.png" srcset="/img/loading.gif" alt="19"></p><p> 完成之后，可以看到流水线任务流程图<br><img src="/images/cicd/21.png" srcset="/img/loading.gif" alt="21"></p><p>下面通过代码推送来测一下，我在跟目录新建一个空的README.md文件，然后推送，推送完成后可以看到Jenkins开始执行第二次构建任务<br><img src="/images/cicd/22.png" srcset="/img/loading.gif" alt="22"></p><p>至此，从GitLab提交代码到Jenkins自动构建的整个流程已经完成了，细心的你会发现，只是流程跑通了，这个Jenkinsfile没有实质性的内容，下面进入Jenkinsfile</p><h2 id="四-接入Jenkinsfile，Dockerfile实现自动发布"><a href="#四-接入Jenkinsfile，Dockerfile实现自动发布" class="headerlink" title="四.接入Jenkinsfile，Dockerfile实现自动发布"></a>四.接入Jenkinsfile，Dockerfile实现自动发布</h2><p>编写Dockerfile如下：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> mcr.microsoft.com/dotnet/core/sdk:<span class="hljs-number">3.1</span>-buster AS build<span class="hljs-keyword">COPY</span><span class="bash"> *.csproj ./app/</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-keyword">RUN</span><span class="bash"> dotnet restore</span><span class="hljs-keyword">COPY</span><span class="bash"> . ./</span><span class="hljs-keyword">RUN</span><span class="bash"> dotnet publish -o out /p:PublishWithAspNetCoreTargetManifest=<span class="hljs-string">"false"</span></span><span class="hljs-keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="hljs-number">3.1</span>-buster-slim AS runtime<span class="hljs-keyword">ENV</span> ASPNETCORE_URLS http://+:<span class="hljs-number">80</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-keyword">COPY</span><span class="bash"> --from=build /app/out ./</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"dotnet"</span>, <span class="hljs-string">"WebApplication_Jenkinsfile.dll"</span>]</span></code></pre><p>编写Jenkinsfile如下：</p><pre><code class="hljs awk">pipeline&#123;    agent any    stages &#123;        stage(<span class="hljs-string">'Checkout'</span>) &#123;            steps&#123;            git credentialsId: <span class="hljs-string">'85ca7e47-532e-4901-9828-50a8da071d16'</span>, url: <span class="hljs-string">'http://xxx.gitlab.com/webapplication_jenkinsfile.git'</span>, branch:<span class="hljs-string">'master'</span>                    echo <span class="hljs-string">'---This is a Checkout step---'</span>                             &#125;        &#125;        stage(<span class="hljs-string">'Build'</span>) &#123;            steps&#123;                    sh <span class="hljs-string">'''cd WebApplication_Jenkinsfile</span><span class="hljs-string">            docker rmi -f docker_webapplication_test:1.0</span><span class="hljs-string">            docker build -t docker_webapplication_test:1.0 .'''</span>            echo <span class="hljs-string">'---This is a Build step---'</span>            &#125;        &#125;        stage(<span class="hljs-string">'Run'</span>) &#123;            steps&#123;            sh <span class="hljs-string">'''docker rm -f docker_webapplication_test</span><span class="hljs-string">            docker run --name docker_webapplication_test -d -p 7489:80 docker_webapplication_test:1.0</span><span class="hljs-string">            '''</span>                    echo <span class="hljs-string">'---This is a run step---'</span>                &#125;        &#125;    &#125;&#125;</code></pre><p><strong>说明:</strong></p><ul><li>stages 必须，包括顺序执行的一个或多个stage命令，在pipeline内仅能使用一次，通常位于agent/options后面</li><li>steps 必须，steps位于stage指令块内部，包括一个或多个step。仅有一个step的情况下可以忽略关键字step及其{}</li></ul><p>这里为了演示，只添加了几个核心的步骤，可以根据需要自行添加自动测试，邮件提醒等额外步骤</p><p>流水线语法，可以参照下图中的示例步骤点击后，可以生成脚本信息，上面Jenkinsfile中的git credentialsId信息就是在这里生成的<br><img src="/images/cicd/23.png" srcset="/img/loading.gif" alt="23"></p><p>完成之后，将Jenkinsfile和Dockerfile推送到Gitlab，推送成功可以看到如下图的Jenkins自动构建过程，并且遵照定义规范发布了应用<br><img src="/images/cicd/24.png" srcset="/img/loading.gif" alt="24"></p><p>如果需要查看日志，或者在发布失败后查看失败原因，可以通过下面的 Console Output来查看<br><img src="/images/cicd/25.png" srcset="/img/loading.gif" alt="25"></p><p>Console Output中的详细日志信息如下图，可以看到构建过程是遵循在Dockerfile中的定义<br><img src="/images/cicd/26.png" srcset="/img/loading.gif" alt="26"></p><p>docker 容器运行状态检查<br><img src="/images/cicd/27.png" srcset="/img/loading.gif" alt="27"></p><p>自动部署效果截图<br><img src="/images/cicd/28.png" srcset="/img/loading.gif" alt="28"></p><h2 id="五-结束总结"><a href="#五-结束总结" class="headerlink" title="五.结束总结"></a>五.结束总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在定义web钩子的时候，我勾选的是push events，所以每次有提交代码到master，都会自动去走Jenkinsfile中的流水线任务，在实际生产中，如果不想这样操作，可以将持续集成流水线与持续发布流水线独立开来<br>其实只需要前期一次将Jenkins和Gitlab触发器打通之后，后面只需要在源代码中维护Dockerfile和Jenkinsfile即可，这是比较优雅的一种CI、CD方式，动手试试吧！</p>]]></content>
    
    
    <categories>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>.NetCore</tag>
      
      <tag>Jenkins</tag>
      
      <tag>Gitlab</tag>
      
      <tag>Docker</tag>
      
      <tag>CI</tag>
      
      <tag>CD</tag>
      
      <tag>DevOps</tag>
      
      <tag>Dockerfile</tag>
      
      <tag>Jenkinsfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CI与CD之Docker上安装Jenkins</title>
    <link href="/2020/05/20/jenkinsinstall/"/>
    <url>/2020/05/20/jenkinsinstall/</url>
    
    <content type="html"><![CDATA[<h2 id="一-CI，CD，Jenkins的介绍"><a href="#一-CI，CD，Jenkins的介绍" class="headerlink" title="一.CI，CD，Jenkins的介绍"></a>一.CI，CD，Jenkins的介绍</h2><ul><li><p>CI：持续集成(Continuous integration，简称 CI)，在传统的软件开发环境中，有集成，但是没有持续集成这种说法，长时间的分支与主干脱离，导致分支与主干可能存在较大偏差，在集成代码的时候可能需要花费数小时更久的时间来修复代码，以便最终将代码集成主干(俗称”集成地狱”或”集成灾难”)；而CI旨在鼓励团队成员进行频繁集成（例如每小时或至少每天一次）来避免这种情况的出现，通过自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程，来保障代码的质量可以进行下一步的使用，这也是持续集成的目的，CI是属于开发人员的自动化流程。</p></li><li><p>CD：持续交付(Continuous Delivery)和持续部署(Continuous Deployment)，这里查阅了一些资料，并简单总结了一下：</p><ol><li>持续交付意味着所有的变更都可以随时交付生产使用，强调的是一种可交付的能力</li><li>持续部署意味着所有被发现的release candidate 并且通过所有质量测试的变更都会被自动部署到生产环境中，强调的是一种方式</li></ol></li><li><p>Jenkins：Jenkins是开源CI&amp;CD软件领导者，并拥有众多插件来支持它用于持续、自动的构建/测试软件项目、监控外部任务的运行</p></li></ul><h2 id="二-在docker上安装Jenkins"><a href="#二-在docker上安装Jenkins" class="headerlink" title="二.在docker上安装Jenkins"></a>二.在docker上安装Jenkins</h2><p>选择jenkins的镜像文件，这里推荐使用jenkinsci/blueocean，该镜像包含当前的长期支持 (LTS) 的Jenkins版本 （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件，镜像地址：<a href="https://hub.docker.com/r/jenkinsci/blueocean/" target="_blank" rel="noopener">https://hub.docker.com/r/jenkinsci/blueocean/</a></p><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span>  -u root <span class="hljs-string">\</span>  --rm <span class="hljs-string">\</span>  -d <span class="hljs-string">\</span>  -p <span class="hljs-number">8083</span>:<span class="hljs-number">8080</span> <span class="hljs-string">\</span>  -p <span class="hljs-number">50000</span>:<span class="hljs-number">50000</span> <span class="hljs-string">\</span>  -v /data/jenkins:/<span class="hljs-keyword">var</span>/jenkins_home <span class="hljs-string">\</span>  -v /<span class="hljs-keyword">var</span>/run/docker.sock:/<span class="hljs-keyword">var</span>/run/docker.sock <span class="hljs-string">\</span>  jenkinsci/blueocean</code></pre><p><strong>参数说明:</strong></p><ul><li>–rm 关闭时自动删除Docker容器（下图为实例）。如果您需要退出Jenkins，这可以保持整洁；</li><li>-d 在后台运行容器；</li><li>-p 映射容器服务的8080端口到宿主机的8090(我的8080已经被Apollo占用，所以改为8083，没被占用的可以不用改，发现很多工具都喜欢用8080端口，比如:Apollo,SkyWalking,还有这里的Jenkins等)端 口，下面的50000也是一样，将容器的端口50000 映射到主机上的端口50000；</li><li>-v 这里是将本机的“/data/jenkins”目录挂载到容器中的/var/jenkins_home中，作为jenkins的存储目录；/var/run/docker.sock 表示Docker守护程序通过其监听的基于Unix的套接字。该映射允许jenkinsci/blueocean 容器与Docker守护进程通信。</li><li>jenkinsci/blueocean 是镜像名称</li></ul><p>docker run的时候，如果镜像文件不存在，则会先自动拉取该镜像，然后再启动容器，通过下图可以看到有提示说明本地不存在该镜像，然后自动拉取的过程<br><img src="/images/jenkinsinstall/1.png" srcset="/img/loading.gif" alt="1"></p><p>等待安装完成之后，打开浏览器访问：http://部署的机器ip:8083 (没改的话默认8080)，就可以看到Jenkins的界面<br><img src="/images/jenkinsinstall/2.png" srcset="/img/loading.gif" alt="2"></p><p>然后通过以下命令访问Jenkins控制台日志，复制出密码（在两组星号之间的就是生成好的管理员密码）如图</p><pre><code class="hljs xml">docker logs <span class="hljs-tag">&lt;<span class="hljs-name">CONTAINER</span> <span class="hljs-attr">ID</span>&gt;</span></code></pre><p><img src="/images/jenkinsinstall/3.png" srcset="/img/loading.gif" alt="3"></p><p>复制出密码后，按照页面的提示，粘贴过去，点击继续就进入下一步骤了<br><img src="/images/jenkinsinstall/4.png" srcset="/img/loading.gif" alt="4"></p><p>这里点击安装推荐的插件，然后等待安装完成<br><img src="/images/jenkinsinstall/5.png" srcset="/img/loading.gif" alt="5"></p><p>插件安装完成后，可根据提示创建用户或者继续使用admin，后面默认点击保存并完成，就可以进入Jenkins的首页了<br><img src="/images/jenkinsinstall/6.png" srcset="/img/loading.gif" alt="6"></p><p>到这里，Jenkins安装流程就已经结束了</p><h2 id="三-分享两个可能用到的命令："><a href="#三-分享两个可能用到的命令：" class="headerlink" title="三.分享两个可能用到的命令："></a>三.分享两个可能用到的命令：</h2><ol><li><p>访问Jenkins / Blue Ocean Docker容器</p><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> &lt;CONTAINER ID&gt; bash</code></pre></li><li><p>访问Jenkins控制台日志</p><pre><code class="hljs xml">docker logs <span class="hljs-tag">&lt;<span class="hljs-name">CONTAINER</span> <span class="hljs-attr">ID</span>&gt;</span></code></pre></li></ol><p>上面获取管理员密码就是就是用的这个命令，部署下来还挺快的，大家动手试试吧！</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用了这么多年MySql，这些好习惯你用过哪些</title>
    <link href="/2020/05/19/mysql01/"/>
    <url>/2020/05/19/mysql01/</url>
    
    <content type="html"><![CDATA[<h2 id="一-新建表和字段建议："><a href="#一-新建表和字段建议：" class="headerlink" title="一.新建表和字段建议："></a>一.新建表和字段建议：</h2><ol><li><p>所有数据表和字段要有清晰的注释，字段说明<br>　　说明：不管是创建者还是其他开发或者后续维护者都能清楚知道数据表和字段定义的含义</p></li><li><p>表名、字段名使用小写字母或数字，禁止出现数字开头<br>　　说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写，为了避免出现不必要的麻烦，统一使用小写</p></li><li><p>每个列都设置为not null（如果列为BLOB/TEXT类型的，则这个列不能设置为NOT NULL)，且定义默认值<br>　　说明：3.1：NOT IN、!= 等负向条件查询在有 NULL 值的情况下返回非空行的结果集<br>　　3.2：使用 concat 函数拼接时，首先要对各个字段进行非 NULL 判断，否则只要任何一个字段为空都会造成拼接的结果为 NULL<br>　　3.3：当用count函数进行统计时，NULL 列不会计入统计<br>　　3.4：因为NULL的列使得索引，索引统计和值比较都更复杂，可为NULL的列会使用更多的存储空间，在mysql里也需要特殊处理，当可为NULL的列被索引时，每个索引记录需要一个额外的字节，如果计划在列上建索引，应该避免将列设计为NULL。</p></li><li><p>每个表有自增列id且为主键，使用无符号类型unsigned，不作业务逻辑使用<br>　　说明：4.1：避免存储负值，且扩大了表示范围<br>　　4.2：如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面</p></li><li><p>表达是否概念的列，使用is_xxx的方式命名，数据类型使用unsigned tinyint（1表示是，0表示否）<br>　　例如：is_valid，1.表示有效 0.表示无效</p></li><li><p>禁止使用mysql保留字，例如desc，range，match，action，add，alter，all..等等<br>　　更多保留字可以参考mysql官方文档说明：<a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/keywords.html</a></p></li><li><p>varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率</p></li><li><p>单表行数 超过500万行或者表单容量超过2GB，才推荐进行分库分表</p></li><li><p>命令规范：主键索引名以pk_字段名；唯一索引名uk_字段名；普通索引名idx_字段名；临时表则以tmp为前缀</p></li><li><p>小数类型为decimal，禁止使用float和double<br>　　说明：float和double的存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储</p></li><li><p>字段允许适当冗余，以提高查询性能，冗余字段应遵循：1）不是频繁修改的字段。2）不是varchar超长字段，更不能是text字段。</p></li><li><p>InnoDB和MyISAM存储引擎表，索引类型选择BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引。</p></li><li><p>在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面，这样可以更高效检索数据</p></li><li><p>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度</p><table><thead><tr><th align="left">对象</th><th align="left">年龄区间</th><th align="left">类型</th><th align="left">字节</th><th align="left">表示范围</th></tr></thead><tbody><tr><td align="left">人</td><td align="left">150之内</td><td align="left">unsigned tinyint</td><td align="left">1</td><td align="left">无符号：0-255</td></tr><tr><td align="left">龟</td><td align="left">数百岁</td><td align="left">unsigned smallint</td><td align="left">2</td><td align="left">无符号：0-65535</td></tr><tr><td align="left">恐龙化石</td><td align="left">数千年</td><td align="left">unsigned int</td><td align="left">4</td><td align="left">无符号：0-42.9亿</td></tr><tr><td align="left">太阳</td><td align="left">约50亿年</td><td align="left">unsigned bigint</td><td align="left">8</td><td align="left">无符号：0-约10的19次方</td></tr></tbody></table></li></ol><h2 id="二-增删改查好习惯"><a href="#二-增删改查好习惯" class="headerlink" title="二.增删改查好习惯"></a>二.增删改查好习惯</h2><ol><li><p>SELECT语句指定具体字段名称，禁止写成*，select *会将不该读的数据也从MySQL里读出来，造成不必要的带宽压力</p></li><li><p>分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select f1,f2,f3 from table1 limit 20000,20;优化为: select f1,f2,f3 from table1 where id&gt;20000 limit 20</p></li><li><p>where条件里等号左右字段类型一致，否则无法利用索引</p></li><li><p>在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表</p></li><li><p>插入列列表与值列表个数相同，上面二者的个数需要相同，如果没有指定列列表，则值列表长度要与表列数相同。</p></li><li><p>更新删除影响行数不要太大，如果太大，进行细粒度拆分</p></li><li><p>更新，删除语句记得随手写好where条件(你想删库吗？哈哈)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让.NetCore程序跑在任何有docker的地方</title>
    <link href="/2020/05/18/dotnetcoredocker/"/>
    <url>/2020/05/18/dotnetcoredocker/</url>
    
    <content type="html"><![CDATA[<h2 id="一-分别在Windows-Mac-Centos上安装Docker"><a href="#一-分别在Windows-Mac-Centos上安装Docker" class="headerlink" title="一.分别在Windows/Mac/Centos上安装Docker"></a>一.分别在Windows/Mac/Centos上安装Docker</h2><p>Windows上下载地址：<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a>（window上安装的常见问题和解决方案请参考下方步骤六）<br>Mac上下载地址：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a><br>Centos上安装Docker请参考我上篇文章链接：<a href="https://www.cnblogs.com/peyshine/p/12915317.html" target="_blank" rel="noopener">https://www.cnblogs.com/peyshine/p/12915317.html</a></p><h2 id="二-打开vs-新建一个Web程序"><a href="#二-打开vs-新建一个Web程序" class="headerlink" title="二.打开vs 新建一个Web程序"></a>二.打开vs 新建一个Web程序</h2><p><img src="/images/dotnetcoredocker/1.png" srcset="/img/loading.gif" alt="1"><br>这里选择启动docker支持，主要是为了能够自动生成dockerfile文件，如果忘记勾选了也没关系，也可以右键解决方案，点击‘添加’，选择‘docker支持’，vs也会自动为我们生成dockerfile，大概长这个样子<br><img src="/images/dotnetcoredocker/2.png" srcset="/img/loading.gif" alt><br><img src="/images/dotnetcoredocker/3.png" srcset="/img/loading.gif" alt></p><p><strong>对dockerfile文件解释说明：</strong></p><ol><li>FROM<br>通过FROM指令来设置要制作的镜像基于哪个镜像，FROM指令必须是整个Dockerfile的第一个指令，如果指定的镜像不存在默认会自动从Docker Hub上进行拉取</li><li>WORKDIR<br>通过workdir指令用于设置Dockerfile中的RUN、CMD和ENTRYPOINT指令执行命令的工作目录(默认为/目录)，该指令在Dockerfile文件中可以出现多次，如果使用相对路径则为相对于WORKDIR上一次的值</li><li>COPY<br>通过COPY指令来从指定路径拷贝一个文件或目录到容器的指定路径中</li><li>RUN<br>RUN指令会在一个新的容器中执行任何命令，然后把执行后的改变提交到当前镜像，提交后的镜像会被用于Dockerfile中定义的下一步操作，RUN中定义的命令会按顺序执行并提交，这正是Docker廉价的提交和可以基于镜像的任何一个历史点创建容器的好处，就像版本控制工具一样</li><li>EXPOSE<br>通过EXPOSE指令用来告诉Docker这个容器在运行时会监听哪些端口</li><li>ENTRYPOINT<br>通过ENTRYPOINT指令我们指定在容器启动时要运行的应用程序</li></ol><p>关于dockerfile的更多用法可以参考：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><h2 id="三-DotNet-Core-程序在Windows-Docker上的运行"><a href="#三-DotNet-Core-程序在Windows-Docker上的运行" class="headerlink" title="三.DotNet Core 程序在Windows Docker上的运行"></a>三.DotNet Core 程序在Windows Docker上的运行</h2><p><img src="/images/dotnetcoredocker/4.png" srcset="/img/loading.gif" alt><br>直接在VS中选择以docker方式运行，VS的输出控制台就会打印以下信息内容<br><img src="/images/dotnetcoredocker/5.png" srcset="/img/loading.gif" alt></p><p><strong>可以看到运行之前，VS先做了几个检查工作</strong></p><ul><li>windows上是否安装了Docker Desktop</li><li>Docker Desktop是否在运行</li><li>Docker Desktop的操作系统模式是否与项目的目标操作系统匹配</li><li>指定需要的镜像本地是否存在，不存在的就会进行拉取</li><li>检查完了之后就是打包镜像和运行容器</li></ul><h2 id="四-打包发布镜像到https-hub-docker-com"><a href="#四-打包发布镜像到https-hub-docker-com" class="headerlink" title="四.打包发布镜像到https://hub.docker.com/"></a>四.打包发布镜像到<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></h2><p>选择发布到Docker hub，输入自己的账号密码，没有的话可以注册一个<br><img src="/images/dotnetcoredocker/6.png" srcset="/img/loading.gif" alt></p><p>点击发布之后，输出控制台可以看到有build打包的过程<br><img src="/images/dotnetcoredocker/7.png" srcset="/img/loading.gif" alt></p><p>发布完成之后，控制台会有对应的提示信息，已经成功推送带标记的‘latest’的Docker镜像<br><img src="/images/dotnetcoredocker/8.png" srcset="/img/loading.gif" alt></p><p>进入Docker hub上，在自己的账户的存储库下面会多处一个镜像文件，也就是刚刚推送过去的<br><img src="/images/dotnetcoredocker/9.png" srcset="/img/loading.gif" alt></p><p>点击进入，可以看到拉取的命令<br><img src="/images/dotnetcoredocker/10.png" srcset="/img/loading.gif" alt></p><p>在powershell中拉取自己的镜像<br><img src="/images/dotnetcoredocker/11.png" srcset="/img/loading.gif" alt></p><p>运行容器，运行成功会返回一个长的字符串，通过docker ps指令，可以查看容器已经成功运行起来了<br><img src="/images/dotnetcoredocker/12.png" srcset="/img/loading.gif" alt></p><p>那么这个镜像是否能在linux上拉取并运行呢？答案是否定的，因为在添加docker支持时候，我这边选了平台支持为windows，如图<br><img src="/images/dotnetcoredocker/13.png" srcset="/img/loading.gif" alt></p><p>步骤四：只是玩一下怎么打包推送镜像文件，不关注的可以直接跳过步骤四</p><h2 id="五-DotNet-Core-程序在Centos-Docker上的运行"><a href="#五-DotNet-Core-程序在Centos-Docker上的运行" class="headerlink" title="五.DotNet Core 程序在Centos Docker上的运行"></a>五.DotNet Core 程序在Centos Docker上的运行</h2><p>重新在VS中添加一个dockerfile，这次选择linux平台的<br><img src="/images/dotnetcoredocker/14.png" srcset="/img/loading.gif" alt></p><p>这次我们需要修改下dockerfile文件<br>因为我们提前编译并且发布出来了文件，所以在dockerfile中就不需要这些步骤了<br><img src="/images/dotnetcoredocker/15.png" srcset="/img/loading.gif" alt></p><p>贴一下dockerfile文件</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="hljs-number">3.1</span>-buster-slim AS base<span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><span class="hljs-keyword">COPY</span><span class="bash"> . /app</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"dotnet"</span>, <span class="hljs-string">"WebApp_Docker.dll"</span>]</span></code></pre><p>发布后将Release文件下所有文件上传到centos上，然后执行以下命令打包镜像</p><pre><code class="hljs angelscript">docker build -t docker_web_test:<span class="hljs-number">1.0</span> .</code></pre><p>后面的点可以打印出具体的执行步骤细节<br><img src="/images/dotnetcoredocker/16.png" srcset="/img/loading.gif" alt></p><p>通过指令验证打包结果：# docker images<br><img src="/images/dotnetcoredocker/17.png" srcset="/img/loading.gif" alt></p><p>最后运行容器</p><pre><code class="hljs angelscript">docker run --name docker_web_test -d -p <span class="hljs-number">7788</span>:<span class="hljs-number">80</span> docker_web_test:<span class="hljs-number">1.0</span></code></pre><p><img src="/images/dotnetcoredocker/18.png" srcset="/img/loading.gif" alt><br>可以看到容器已经运行起来，并且可以输出页面内容。</p><h2 id="六-可能遇见的错误解决方案以及小提示："><a href="#六-可能遇见的错误解决方案以及小提示：" class="headerlink" title="六.可能遇见的错误解决方案以及小提示："></a>六.可能遇见的错误解决方案以及小提示：</h2><p>1.在window上安装docker时需要勾选上Hyper-V<br><img src="/images/dotnetcoredocker/19.png" srcset="/img/loading.gif" alt></p><p>2.如果在运行容器过程中依然提示错误：“The virtual machine could not be started because a required feature is not installed”，那就需要检查bios中的虚拟功能，拿我的华硕主板和inter处理器来示范，将Inter(VMX) Virtualization Tecjnology 的值设置为 Enabled<br><img src="/images/dotnetcoredocker/20.png" srcset="/img/loading.gif" alt><br>然后保存设置退出即可</p><p>3.当我们在windows上拉取镜像碰到提示镜像在当前操作系统不支持的时候，可以在linux和Windows容器之间切换。如图<br><img src="/images/dotnetcoredocker/21.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>.netcore</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在微服务框架Demo.MicroServer中添加SkyWalking+SkyApm-dotnet分布式链路追踪系统</title>
    <link href="/2020/05/16/skywalking/"/>
    <url>/2020/05/16/skywalking/</url>
    
    <content type="html"><![CDATA[<h2 id="1-APM工具的选取"><a href="#1-APM工具的选取" class="headerlink" title="1.APM工具的选取"></a>1.APM工具的选取</h2><p>Apm监测工具很多，这里选用网上比较火的一款Skywalking。<br>Skywalking是一个应用性能监控(APM)系统，Skywalking分为服务端Oap、管理界面UI、以及嵌入到程序中的探针Agent部分，大概工作流程就是在程序中添加探针采集各种数据发送给服务端保存，然后在UI界面可以看到收集过来的各种监测数据，来完成它的核心使命：性能监控和分布式调用链追踪能力。下图是skywalking官方的一个图，也可以说明这三者之间的关联关系<br><img src="/images/skywalking/1.png" srcset="/img/loading.gif" alt="1"></p><h2 id="2-服务端-OAP-和界面-UI-的安装"><a href="#2-服务端-OAP-和界面-UI-的安装" class="headerlink" title="2.服务端(OAP)和界面(UI)的安装"></a>2.服务端(OAP)和界面(UI)的安装</h2><p>这里直接在apache地址：<a href="http://skywalking.apache.org/downloads/" target="_blank" rel="noopener">http://skywalking.apache.org/downloads/</a> 下载了一个6.6.0版本的zip文件，由于之前在本地的windows上安装过，发现安装包里面有两个启动文件，分别为：startup.bat和startup.sh，分别用于window上启动和linux启动，这里我直接将之前下载好的上传到linux上来安装。<br><img src="/images/skywalking/2.png" srcset="/img/loading.gif" alt="2"></p><p>上传后解压缩，就会得到以下截图的几个文件<br><img src="/images/skywalking/3.png" srcset="/img/loading.gif" alt="3"></p><p>进入到config配置目录下面，有一个名称叫application.yml的文件<br><img src="/images/skywalking/4.png" srcset="/img/loading.gif" alt="4"></p><p>对这个配置文件进行编辑 vim application.yml<br><img src="/images/skywalking/5.png" srcset="/img/loading.gif" alt="5"></p><p>我们直接定位到数据存储部分，也就是节点storage，官方文档里面也有说明，为了方便快速入门，配置文件默认采用的是H2存储，但是推荐使用ElasticSearch存储，由于之前我安装过Exceptionless，在这台机器上已经安装过elasticsearch(如果没有安装过可以网上找下，有很多这方面的文章)，所以我这里将H2部分注释掉，然后将elasticsearch部分放开，并修改红色方框里的两个配置文件：</p><pre><code class="hljs groovy"><span class="hljs-string">nameSpace:</span> $&#123;<span class="hljs-string">SW_NAMESPACE:</span><span class="hljs-string">"exceptionless"</span>&#125;<span class="hljs-string">clusterNodes:</span> $&#123;<span class="hljs-string">SW_STORAGE_ES_CLUSTER_NODES:</span><span class="hljs-string">localhost:</span><span class="hljs-number">9300</span>&#125;</code></pre><p>需要注意的是：第一个SW_NAMESPACE需要与ElasticSearch配置的cluster_name名称一致</p><p>启动skywalking会占用四个端口：8080，10800，11800，12800，由于我本机安装过apollo，8080ui端口已经被占用，所以这里我必须要先修改UI界面使用的8080端口才能启动它。<br>开始修改UI界面使用的8080端口（如果你的8080端口并没有被占用，可以跳过，不用修改）<br>回到配置目录的上一级：cd ..<br>可以看到一个webapp的文件夹<br><img src="/images/skywalking/6.png" srcset="/img/loading.gif" alt="6"></p><p>进入这个目录：cd webapp/<br>然后对webapp.yml文件进行修改<br><img src="/images/skywalking/7.png" srcset="/img/loading.gif" alt="7"></p><p>这里我将原来server界面下面的port从8080改到8088，然后保存<br><img src="/images/skywalking/8.png" srcset="/img/loading.gif" alt="8"></p><p>配置文件修改完了，开始启动skywalking的服务端和UI界面，启动脚本放在目录：apache-skywalking-apm-bin/bin 里面<br><img src="/images/skywalking/9.png" srcset="/img/loading.gif" alt="9"></p><p>上面有说到startup.bat和startup.sh分别用在windows上和linux上启动，这里用./startup.sh<br><img src="/images/skywalking/10.png" srcset="/img/loading.gif" alt="10"></p><p>启动命令执行完成之后可以看到OAP和Web两个项目启动成功的提示，也就是我们说的服务端和UI界面。<br>验证一下，通过配置的ip+8088端口(如果没有修改则是默认的8080)来访问一下界面，如图：<br><img src="/images/skywalking/11.png" srcset="/img/loading.gif" alt="11"></p><p>至此，我们准备工作做完了，下面我们在程序中安装探针，来采集数据.</p><h2 id="3-安装探针-Agent-采集数据"><a href="#3-安装探针-Agent-采集数据" class="headerlink" title="3.安装探针(Agent)采集数据"></a>3.安装探针(Agent)采集数据</h2><p>由于Skywalking本身是采用java编写的，所以SkyApm-dotnet这个项目就是专门为 .NET 开发的探针，目前支持 ASP.NET Core 以及 ASP.NET，下面我们将SkyApm-dotnet无侵入式的集成到.Net Core实现的微服务项目中</p><p>第一步：使用下面的命令来进行 Agent 的安装，这里据说需要以管理员身份运行</p><pre><code class="hljs routeros">dotnet<span class="hljs-built_in"> tool </span>install -g SkyAPM.DotNet.CLI</code></pre><p>第二步：添加环境变量，可以直接在launchSettings.json文件中添加以下代码来设置</p><pre><code class="hljs 1c"><span class="hljs-string">"environmentVariables"</span>: &#123;    <span class="hljs-string">"ASPNETCORE_ENVIRONMENT"</span>: <span class="hljs-string">"Development"</span>,    <span class="hljs-string">"ASPNETCORE_HOSTINGSTARTUPASSEMBLIES"</span>: <span class="hljs-string">"SkyAPM.Agent.AspNetCore"</span>,    <span class="hljs-string">"SKYWALKING__SERVICENAME"</span>: <span class="hljs-string">"Demo.MicroServer.UserService"</span>&#125;</code></pre><p>第三步：在程序中安装NuGet包：SkyAPM.Agent.AspNetCore</p><p>第四步：在应用程序根目录下使用以下命令生成skyapm.json的配置文件，[service name]替换为服务的名称，[server]替换为Skywalking安装的计器ip</p><pre><code class="hljs routeros">dotnet skyapm<span class="hljs-built_in"> config </span>[service name] [server]:11800</code></pre><p><img src="/images/skywalking/12.png" srcset="/img/loading.gif" alt="12"><br>执行完成之后可以看到目录下面已经生成了一个skyapm.json的文件，将其属性复制到输出目录设置为如果较新则复制，我这里是用之前发布在github上的微服务框架中的一个实例来测试的，所有代码均已上传，需要的可以通过页Github地址获取代码:<a href="https://github.com/PeyShine/Demo.MicroServer" target="_blank" rel="noopener">https://github.com/PeyShine/Demo.MicroServer</a></p><h2 id="4-采集数据并查看"><a href="#4-采集数据并查看" class="headerlink" title="4.采集数据并查看"></a>4.采集数据并查看</h2><p>在Swagger中随便调用几个接口来测试数据的采集情况，然后到UI界面查看数据，流程顺利的话，可以看到数据已经都有采集到<br><img src="/images/skywalking/13.png" srcset="/img/loading.gif" alt="13"><br><img src="/images/skywalking/14.png" srcset="/img/loading.gif" alt="14"></p><p>基本工作都已经完成，这个里面还有很多玩法，快动手试试吧。</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>SkyWalking</tag>
      
      <tag>.netcore</tag>
      
      <tag>C#</tag>
      
      <tag>SkyApm-dotnet</tag>
      
      <tag>Apm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在微服务框架Demo.MicroServer中添加对MongoDB的支持</title>
    <link href="/2020/05/14/microseversupportmongodb/"/>
    <url>/2020/05/14/microseversupportmongodb/</url>
    
    <content type="html"><![CDATA[<h2 id="前提说明："><a href="#前提说明：" class="headerlink" title="前提说明："></a>前提说明：</h2><p>本编文章所属的微服务框架代码和对mongo支持的代码全部放在github，地址：<a href="https://github.com/PeyShine/Demo.MicroServer" target="_blank" rel="noopener">https://github.com/PeyShine/Demo.MicroServer</a><br>另外，如果不知道怎么安装mongodb可以看这篇：<a href="http://liuthing.com/2020/05/13/dockerinstallmongodb/">http://liuthing.com/2020/05/13/dockerinstallmongodb/</a></p><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><p>在数据仓储层Demo.MicroServer.Repository，添加Mongo依赖包：dotnet add package MongoDB.Driver</p><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><p>编写mongo常用的一些接口以及接口的实现，后续可以根据实际开发情况再进行更多接口的封装</p><pre><code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> mongoDB服务</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMongoService</span>&#123;    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 新增记录</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="t"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="mongoTable"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>    <span class="hljs-keyword">int</span> Add&lt;T&gt;(T t, <span class="hljs-keyword">string</span> mongoTable = <span class="hljs-literal">null</span>);    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 异步-新增记录</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="t"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="mongoTable"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>    Task&lt;<span class="hljs-keyword">int</span>&gt; AddAsync&lt;T&gt;(T t, <span class="hljs-keyword">string</span> mongoTable = <span class="hljs-literal">null</span>);    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 根据过滤条件获取数量</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="filter"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="mongoTable"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>    <span class="hljs-keyword">long</span> Count&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-keyword">string</span> mongoTable = <span class="hljs-literal">null</span>);    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 异步-根据过滤条件获取数量</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="filter"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="mongoTable"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>    Task&lt;<span class="hljs-keyword">long</span>&gt; CountAsync&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-keyword">string</span> mongoTable = <span class="hljs-literal">null</span>);    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 分页获取数据</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="filter"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="pageIndex"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="pageSize"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="field"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="sort"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="mongoTable"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>    List&lt;T&gt; FindListByPage&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-keyword">int</span> pageIndex, <span class="hljs-keyword">int</span> pageSize, <span class="hljs-keyword">string</span>[] field = <span class="hljs-literal">null</span>, SortDefinition&lt;T&gt; sort = <span class="hljs-literal">null</span>, <span class="hljs-keyword">string</span> mongoTable = <span class="hljs-literal">null</span>);    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 异步-分页获取数据</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="filter"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="pageIndex"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="pageSize"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="field"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="sort"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="mongoTable"&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>    Task&lt;List&lt;T&gt;&gt; FindListByPageAsync&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-keyword">int</span> pageIndex, <span class="hljs-keyword">int</span> pageSize, <span class="hljs-keyword">string</span>[] field = <span class="hljs-literal">null</span>, SortDefinition&lt;T&gt; sort = <span class="hljs-literal">null</span>, <span class="hljs-keyword">string</span> mongoTable = <span class="hljs-literal">null</span>);&#125;</code></pre><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MongoService: IMongoService&#123;    <span class="hljs-keyword">private</span> readonly MongoClient _mongoClient;    <span class="hljs-keyword">private</span> IMongoDatabase _mongoDatabase;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _mongoTable;    public <span class="hljs-constructor">MongoService(IConfiguration <span class="hljs-params">configuration</span>)</span>    &#123;        _mongoClient = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MongoClient(<span class="hljs-params">configuration</span>[<span class="hljs-string">"MongoDB.DefaultConnection"</span>])</span>;        _mongoDatabase = _mongoClient.<span class="hljs-constructor">GetDatabase(<span class="hljs-params">configuration</span>[<span class="hljs-string">"MongoDB.DefaultDatabase"</span>])</span>;        _mongoTable = configuration<span class="hljs-literal">["M<span class="hljs-identifier">ongoDB</span>.D<span class="hljs-identifier">efaultTable</span>"]</span>;    &#125;    public <span class="hljs-built_in">int</span> Add&lt;T&gt;(T t,<span class="hljs-built_in">string</span> mongoTable = null)    &#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.<span class="hljs-constructor">IsNullOrEmpty(<span class="hljs-params">mongoTable</span>)</span>)                _mongoTable = mongoTable;            var _tb = _mongoDatabase.GetCollection&lt;T&gt;(_mongoTable).<span class="hljs-constructor">WithReadPreference(ReadPreference.PrimaryPreferred)</span>;            _tb.<span class="hljs-constructor">InsertOne(<span class="hljs-params">t</span>)</span>;            return <span class="hljs-number">1</span>;        &#125;        catch        &#123;            return <span class="hljs-number">0</span>;        &#125;    &#125;    public async Task&lt;<span class="hljs-built_in">int</span>&gt; AddAsync&lt;T&gt;(T t, <span class="hljs-built_in">string</span> mongoTable = null)    &#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.<span class="hljs-constructor">IsNullOrEmpty(<span class="hljs-params">mongoTable</span>)</span>)                _mongoTable = mongoTable;            var _tb = _mongoDatabase.GetCollection&lt;T&gt;(_mongoTable).<span class="hljs-constructor">WithReadPreference(ReadPreference.PrimaryPreferred)</span>;            await _tb.<span class="hljs-constructor">InsertOneAsync(<span class="hljs-params">t</span>)</span>;            return <span class="hljs-number">1</span>;        &#125;        catch        &#123;            return <span class="hljs-number">0</span>;        &#125;    &#125;    public long Count&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-built_in">string</span> mongoTable = null)    &#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.<span class="hljs-constructor">IsNullOrEmpty(<span class="hljs-params">mongoTable</span>)</span>)                _mongoTable = mongoTable;            var _tb = _mongoDatabase.GetCollection&lt;T&gt;(_mongoTable).<span class="hljs-constructor">WithReadPreference(ReadPreference.PrimaryPreferred)</span>;            return _tb.<span class="hljs-constructor">CountDocuments(<span class="hljs-params">filter</span>)</span>;        &#125;        catch (Exception ex)        &#123;            throw ex;        &#125;    &#125;    public async Task&lt;long&gt; CountAsync&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-built_in">string</span> mongoTable = null)    &#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.<span class="hljs-constructor">IsNullOrEmpty(<span class="hljs-params">mongoTable</span>)</span>)                _mongoTable = mongoTable;            var _tb = _mongoDatabase.GetCollection&lt;T&gt;(_mongoTable).<span class="hljs-constructor">WithReadPreference(ReadPreference.PrimaryPreferred)</span>;            return await _tb.<span class="hljs-constructor">CountDocumentsAsync(<span class="hljs-params">filter</span>)</span>;        &#125;        catch (Exception ex)        &#123;            throw ex;        &#125;    &#125;    public List&lt;T&gt; FindListByPage&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-built_in">int</span> pageIndex=<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span> pageSize=<span class="hljs-number">20</span>, <span class="hljs-built_in">string</span><span class="hljs-literal">[]</span> field = null, SortDefinition&lt;T&gt; sort = null, <span class="hljs-built_in">string</span> mongoTable = null)    &#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.<span class="hljs-constructor">IsNullOrEmpty(<span class="hljs-params">mongoTable</span>)</span>)                _mongoTable = mongoTable;            var _tb = _mongoDatabase.GetCollection&lt;T&gt;(_mongoTable).<span class="hljs-constructor">WithReadPreference(ReadPreference.PrimaryPreferred)</span>;            <span class="hljs-comment">//不指定查询字段</span>            <span class="hljs-keyword">if</span> (field<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>field.Length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (sort<span class="hljs-operator"> == </span>null) return _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToList()</span>;                <span class="hljs-comment">//进行排序</span>                return _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.<span class="hljs-constructor">Sort(<span class="hljs-params">sort</span>)</span>.<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToList()</span>;            &#125;            <span class="hljs-comment">//制定查询字段</span>            var fieldList = <span class="hljs-keyword">new</span> List&lt;ProjectionDefinition&lt;T&gt;&gt;<span class="hljs-literal">()</span>;            for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; field.Length; i++)            &#123;                fieldList.<span class="hljs-constructor">Add(Builders&lt;T&gt;.Projection.Include(<span class="hljs-params">field</span>[<span class="hljs-params">i</span>].ToString()</span>));            &#125;            var projection = Builders&lt;T&gt;.Projection.<span class="hljs-constructor">Combine(<span class="hljs-params">fieldList</span>)</span>;            fieldList?.<span class="hljs-constructor">Clear()</span>;            <span class="hljs-comment">//不排序</span>            <span class="hljs-keyword">if</span> (sort<span class="hljs-operator"> == </span>null) return _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.Project&lt;T&gt;(projection).<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToList()</span>;            <span class="hljs-comment">//排序查询</span>            return _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.<span class="hljs-constructor">Sort(<span class="hljs-params">sort</span>)</span>.Project&lt;T&gt;(projection).<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToList()</span>;        &#125;        catch (Exception ex)        &#123;            throw ex;        &#125;    &#125;    public async Task&lt;List&lt;T&gt;&gt; FindListByPageAsync&lt;T&gt;(FilterDefinition&lt;T&gt; filter, <span class="hljs-built_in">int</span> pageIndex=<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span> pageSize=<span class="hljs-number">20</span>, <span class="hljs-built_in">string</span><span class="hljs-literal">[]</span> field = null, SortDefinition&lt;T&gt; sort = null, <span class="hljs-built_in">string</span> mongoTable = null)    &#123;        <span class="hljs-keyword">try</span>        &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.<span class="hljs-constructor">IsNullOrEmpty(<span class="hljs-params">mongoTable</span>)</span>)                _mongoTable = mongoTable;            var _tb = _mongoDatabase.GetCollection&lt;T&gt;(_mongoTable).<span class="hljs-constructor">WithReadPreference(ReadPreference.PrimaryPreferred)</span>;            <span class="hljs-comment">//不指定查询字段</span>            <span class="hljs-keyword">if</span> (field<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>field.Length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (sort<span class="hljs-operator"> == </span>null) return await _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToListAsync()</span>;                <span class="hljs-comment">//进行排序</span>                return await _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.<span class="hljs-constructor">Sort(<span class="hljs-params">sort</span>)</span>.<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToListAsync()</span>;            &#125;            <span class="hljs-comment">//制定查询字段</span>            var fieldList = <span class="hljs-keyword">new</span> List&lt;ProjectionDefinition&lt;T&gt;&gt;<span class="hljs-literal">()</span>;            for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; field.Length; i++)            &#123;                fieldList.<span class="hljs-constructor">Add(Builders&lt;T&gt;.Projection.Include(<span class="hljs-params">field</span>[<span class="hljs-params">i</span>].ToString()</span>));            &#125;            var projection = Builders&lt;T&gt;.Projection.<span class="hljs-constructor">Combine(<span class="hljs-params">fieldList</span>)</span>;            fieldList?.<span class="hljs-constructor">Clear()</span>;            <span class="hljs-comment">//不排序</span>            <span class="hljs-keyword">if</span> (sort<span class="hljs-operator"> == </span>null) return await _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.Project&lt;T&gt;(projection).<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToListAsync()</span>;            <span class="hljs-comment">//排序查询</span>            return await _tb.<span class="hljs-constructor">Find(<span class="hljs-params">filter</span>)</span>.<span class="hljs-constructor">Sort(<span class="hljs-params">sort</span>)</span>.Project&lt;T&gt;(projection).<span class="hljs-constructor">Skip((<span class="hljs-params">pageIndex</span> - 1)</span><span class="hljs-operator"> * </span>pageSize).<span class="hljs-constructor">Limit(<span class="hljs-params">pageSize</span>)</span>.<span class="hljs-constructor">ToListAsync()</span>;        &#125;        catch (Exception ex)        &#123;            throw ex;        &#125;    &#125;&#125;</code></pre><p>构造函数中的mongodb的配置文件全部读取Apollo配置中心<br><img src="/images/microserversupportmongodb/1.png" srcset="/img/loading.gif" alt="1"></p><h2 id="3-在具体使用mongo的微服务实例的Startup文件ConfigureServices中向容器添加接口与实现"><a href="#3-在具体使用mongo的微服务实例的Startup文件ConfigureServices中向容器添加接口与实现" class="headerlink" title="3.在具体使用mongo的微服务实例的Startup文件ConfigureServices中向容器添加接口与实现"></a>3.在具体使用mongo的微服务实例的Startup文件ConfigureServices中向容器添加接口与实现</h2><pre><code class="hljs elm"><span class="hljs-title">services</span>.<span class="hljs-type">AddTransient</span>(typeof(<span class="hljs-type">IMongoService</span>), typeof(<span class="hljs-type">MongoService</span>));</code></pre><h2 id="4-编写与mongoDB交互的测试接口"><a href="#4-编写与mongoDB交互的测试接口" class="headerlink" title="4.编写与mongoDB交互的测试接口"></a>4.编写与mongoDB交互的测试接口</h2><pre><code class="hljs cs"><span class="hljs-comment">// &lt;summary&gt;</span><span class="hljs-comment"><span class="hljs-doctag">///</span> 测试从mongodb中获取用户数量</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span>[<span class="hljs-meta">HttpGet</span>]<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">long</span>&gt; <span class="hljs-title">GetMongoUserCount</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;FilterDefinition&lt;user_mongo&gt;&gt;();    list.Add(Builders&lt;user_mongo&gt;.Filter.Exists(<span class="hljs-string">"user_id"</span>, <span class="hljs-literal">true</span>));    <span class="hljs-keyword">var</span> filter = Builders&lt;user_mongo&gt;.Filter.And(list);      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _mongoService.CountAsync(filter, <span class="hljs-string">"users"</span>);&#125;</code></pre><h2 id="5-在mongo中准备两条测试数据"><a href="#5-在mongo中准备两条测试数据" class="headerlink" title="5.在mongo中准备两条测试数据"></a>5.在mongo中准备两条测试数据</h2><p><img src="/images/microserversupportmongodb/2.png" srcset="/img/loading.gif" alt="2"></p><h2 id="6-在swagger中调用接口来测试"><a href="#6-在swagger中调用接口来测试" class="headerlink" title="6.在swagger中调用接口来测试"></a>6.在swagger中调用接口来测试</h2><p><img src="/images/microserversupportmongodb/3.png" srcset="/img/loading.gif" alt="3"><br>最后看到输出结果为数量为2，和添加的数量一致。<br><img src="/images/microserversupportmongodb/4.png" srcset="/img/loading.gif" alt="4"></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>.netcore</tag>
      
      <tag>C#</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Docker中安装MongoDB</title>
    <link href="/2020/05/13/dockerinstallmongodb/"/>
    <url>/2020/05/13/dockerinstallmongodb/</url>
    
    <content type="html"><![CDATA[<h2 id="1-版本选取"><a href="#1-版本选取" class="headerlink" title="1.版本选取"></a>1.版本选取</h2><p>访问mongodb的镜像仓库地址：<a href="https://hub.docker.com/_/mongo?tab=tags&page=1" target="_blank" rel="noopener">https://hub.docker.com/_/mongo?tab=tags&amp;page=1</a><br><img src="/images/dockerinstallmongodb/1.png" srcset="/img/loading.gif" alt="1"><br>这里选取最新版本进行安装，如果想安装其他的可用版本，可以使用命令“docker search mongo”来查看<br><img src="/images/dockerinstallmongodb/2.png" srcset="/img/loading.gif" alt="2"></p><h2 id="2-拉取最新版本镜像"><a href="#2-拉取最新版本镜像" class="headerlink" title="2.拉取最新版本镜像"></a>2.拉取最新版本镜像</h2><p>这里执行命令”sudo docker pull mongo:latest” 拉取最新版的mongodb镜像文件<br><img src="/images/dockerinstallmongodb/3.png" srcset="/img/loading.gif" alt="3"><br>等待镜像拉取完成后，通过命令”sudo docker images”查看下拉取的镜像，可以看到，已经成功拉取到了本地<br><img src="/images/dockerinstallmongodb/4.png" srcset="/img/loading.gif" alt="4"></p><h2 id="3-开始运行"><a href="#3-开始运行" class="headerlink" title="3.开始运行"></a>3.开始运行</h2><p>创建一个文件夹，用作mongodb的数据目录挂载<br><img src="/images/dockerinstallmongodb/5.png" srcset="/img/loading.gif" alt="5"></p><p>运行启动命令“docker run -p 27017:27017 -v /data/mongo:/data/db –name mongodb -d mongo”<br><img src="/images/dockerinstallmongodb/6.png" srcset="/img/loading.gif" alt="6"></p><p><strong>在上面的命令中，几个命令参数的详细解释如下：</strong></p><ul><li>-p 映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务</li><li>-v 为设置容器的挂载目录，这里是将本机的“/data/mongo”目录挂载到容器中的/data/db中，作为 mongodb 的存储目录</li><li>–name 为设置该容器的名称</li><li>-d 设置容器以守护进程方式运行</li></ul><p>通过命令“docker ps”查看容器启动运行情况<br><img src="/images/dockerinstallmongodb/7.png" srcset="/img/loading.gif" alt="7"><br>可以看到mongo容器已经成功运行起来了</p><h2 id="4-使用客户端工具Studio-3T连接mongo"><a href="#4-使用客户端工具Studio-3T连接mongo" class="headerlink" title="4.使用客户端工具Studio 3T连接mongo"></a>4.使用客户端工具Studio 3T连接mongo</h2><p>studiot 3T下载地址:<a href="https://studio3t.com/download/" target="_blank" rel="noopener">https://studio3t.com/download/</a><br><img src="/images/dockerinstallmongodb/8.png" srcset="/img/loading.gif" alt="8"><br><img src="/images/dockerinstallmongodb/9.png" srcset="/img/loading.gif" alt="9"></p><h2 id="5-创建mongo用户"><a href="#5-创建mongo用户" class="headerlink" title="5.创建mongo用户"></a>5.创建mongo用户</h2><p>可以看到一个空的mongo数据库，有一个不太完美的地方在于我们的mongo没有任何账户密码，在裸奔，下面我们执行以下语句，创建一个管理员用户</p><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.createUser</span>(&#123;    <span class="hljs-attribute">user</span>: <span class="hljs-string">'admin'</span>,    <span class="hljs-attribute">pwd</span>: <span class="hljs-string">'Aa123456'</span>,    <span class="hljs-attribute">roles</span>: [ &#123; <span class="hljs-attribute">role</span>: <span class="hljs-string">"userAdminAnyDatabase"</span>, <span class="hljs-attribute">db</span>: <span class="hljs-string">"admin"</span> &#125; ]&#125;);</code></pre><p><img src="/images/dockerinstallmongodb/10.png" srcset="/img/loading.gif" alt="10"></p><h2 id="6-指定auth重新运行服务"><a href="#6-指定auth重新运行服务" class="headerlink" title="6.指定auth重新运行服务"></a>6.指定auth重新运行服务</h2><p>创建完用户我们就要重新启动mongo服务，并且指定auth<br>删除已经运行的mongo容器：docker rm -f mongodb<br>指定验证启动mongo容器：docker run -p 27017:27017 -v /data/mongo:/data/db –name mongodb -d mongo –auth<br>也就是在之前的启动命令后面加上 –auth：需要密码才能访问容器服务</p><p>此时强行访问，可以看到提示，没有授权<br><img src="/images/dockerinstallmongodb/11.png" srcset="/img/loading.gif" alt="11"><br>这里我们在连接的地方指定一下账户密码<br><img src="/images/dockerinstallmongodb/12.png" srcset="/img/loading.gif" alt="12"></p><p>再来查询，已经正确查询出来之前添加的用户信息<br><img src="/images/dockerinstallmongodb/13.png" srcset="/img/loading.gif" alt="13"></p><h2 id="7-创建一个业务数据库和对应的读写账户"><a href="#7-创建一个业务数据库和对应的读写账户" class="headerlink" title="7.创建一个业务数据库和对应的读写账户"></a>7.创建一个业务数据库和对应的读写账户</h2><pre><code class="hljs less"><span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">demo_db</span>;    <span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.createUser</span>(&#123;    <span class="hljs-attribute">user</span>: <span class="hljs-string">'dev'</span>,    <span class="hljs-attribute">pwd</span>: <span class="hljs-string">'Aa123456'</span>,    <span class="hljs-attribute">roles</span>: [ &#123; <span class="hljs-attribute">role</span>: <span class="hljs-string">"readWrite"</span>, <span class="hljs-attribute">db</span>: <span class="hljs-string">"demo_db"</span> &#125; ]&#125;);</code></pre><p><img src="/images/dockerinstallmongodb/14.png" srcset="/img/loading.gif" alt="14"></p><p>然后用这个dev账号来登录<br><img src="/images/dockerinstallmongodb/15.png" srcset="/img/loading.gif" alt="15"></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker在centos上的安装与常用命令大全</title>
    <link href="/2020/05/12/dockerinstall/"/>
    <url>/2020/05/12/dockerinstall/</url>
    
    <content type="html"><![CDATA[<h2 id="一-docker的安装与加速器配置"><a href="#一-docker的安装与加速器配置" class="headerlink" title="一.docker的安装与加速器配置"></a>一.docker的安装与加速器配置</h2><ol><li>安装docker：yum install docker （默认安装路径/var/lib/docker）</li><li>启动docker服务：systemctl start docker.service (sudo service docker start)</li><li>配置开机启动并验证：systemctl enable docker.service</li><li>验证：查看docker版本信息 ： docker version</li><li>配置docker加速器<pre><code class="hljs dts">vim <span class="hljs-meta-keyword">/etc/</span>docker/daemon.json&#123;    <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://registry.docker-cn.com"</span>]&#125;</code></pre></li><li>然后重启docker服务:<pre><code class="hljs routeros">systemctl daemon-reloadsystemctl restart docker (sudo<span class="hljs-built_in"> service </span>docker restart)</code></pre></li></ol><h2 id="二-在docker中运行hello-world实例"><a href="#二-在docker中运行hello-world实例" class="headerlink" title="二.在docker中运行hello world实例"></a>二.在docker中运行hello world实例</h2><p>将image从仓库抓到本地</p><pre><code class="hljs arduino">docker <span class="hljs-built_in">image</span> pull hello-worlddocker <span class="hljs-built_in">run</span> hello-world</code></pre><p>(由于docker run 在发现本地没有存在对应的image的时候，有自动抓取image的功能，所以上面一步不是必须步骤)</p><h2 id="三-常用命令大全"><a href="#三-常用命令大全" class="headerlink" title="三.常用命令大全"></a>三.常用命令大全</h2><ol><li><p>docker version<br>显示docker版本信息</p></li><li><p>docker info<br>显示docker系统信息</p></li><li><p>docker search<br>从Docker Hub查找镜像</p></li><li><p>docker images<br>列出本地镜像</p></li><li><p>docker ps<br>列出所有在运行的容器信息<br>docker ps -a 显示所有的容器，包括未运行的</p></li><li><p>docker pull<br>从镜像仓库中拉取或者更新指定镜像</p></li><li><p>docker start/stop/restart<br>启动/停止/重启容器</p></li><li><p>docker rm<br>删除一个或多个容器<br>docker rm mynginx 删除容器mynginx,正在运行中的容器需要stop后才能删除，或者使用强制删除。<br>docker rm -f mynginx 强制删除运行中的容器mynginx<br>docker rm -f <code>docker ps -a -q</code> 删除所有容器</p></li><li><p>docker rmi<br>删除本地一个或多个镜像<br>docker rmi codehi/nginx:v1 删除镜像codehi/nginx:v1<br>docker rmi -f codehi/nginx:v1 强制删除<br>docker rmi <code>docker images -q</code> 删除所有镜像</p></li><li><p>docker logs<br>获取容器的日志<br>docker logs -f mynginx 跟踪容器mynginx的日志，实时输出的</p></li><li><p>docker history<br>查看指定镜像的创建历史</p></li><li><p>docker login<br>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br>docker login 登录至Docker Hub，下一步会提示输入账号密码</p></li><li><p>docker logout<br>登出Docker Hub</p></li><li><p>docker push<br>将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p></li><li><p>docker commit<br>从容器创建一个新的镜像</p></li><li><p>docker tag<br>标记本地镜像，将其归入某一仓库</p></li><li><p>docker save<br>将指定镜像保存成 tar 归档文件</p></li><li><p>docker load<br>从归档文件中创建镜像</p></li><li><p>docker export<br>将文件系统作为一个tar归档文件导出到STDOUT</p></li><li><p>docker import<br>从归档文件中创建镜像</p></li><li><p>docker kill<br>杀掉一个运行中的容器</p></li><li><p>docker exec -u 0 -it 39aee58111e1/bin/bash<br>进入某个容器内部（u 0 是使用root权限，如果不需要修改文件可以不使用此参数；39aee58111e1为容器id）</p></li></ol><p>欢迎大家继续补充，方便我们想使用的时候可以快速看到，当然，常用的还是记住比较好</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Centos</tag>
      
      <tag>Docker命令大全</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集成.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo的微服务开发框架</title>
    <link href="/2020/05/10/demomicroserver/"/>
    <url>/2020/05/10/demomicroserver/</url>
    
    <content type="html"><![CDATA[<h1 id="集成-NET-Core-Swagger-Consul-Polly-Ocelot-IdentityServer4-Exceptionless-Apollo的微服务开发框架"><a href="#集成-NET-Core-Swagger-Consul-Polly-Ocelot-IdentityServer4-Exceptionless-Apollo的微服务开发框架" class="headerlink" title="集成.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo的微服务开发框架"></a>集成.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo的微服务开发框架</h1><h2 id="Github源代码地址"><a href="#Github源代码地址" class="headerlink" title="Github源代码地址"></a>Github源代码地址</h2><p><a href="https://github.com/PeyShine/Demo.MicroServer" target="_blank" rel="noopener">https://github.com/PeyShine/Demo.MicroServer</a></p><h2 id="Apollo配置中心"><a href="#Apollo配置中心" class="headerlink" title="Apollo配置中心"></a>Apollo配置中心</h2><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。<br>由于各个项目配置都需要读取基础的配置信息，这边在内网的Centos(101)上部署了Apollo的环境，并为项目添加了一些基础配置信息，配置如图<br><img src="/images/demomicroserver/apollo.png" srcset="/img/loading.gif" alt="1"></p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>Consul是一种服务网格解决方案，提供具有服务发现，健康检查，Key/Value存储，多数据中心等功能。<br>在内网101启动Consul服务，这里为了测试，直接在本地将用户服务实例分别在三个端口启动起来，实际生产中这些服务可能部署在不同的机房不同的机器，他们之间组成一个服务的集群，服务提供一个心跳检测的方法，用于consul定时检测服务实例是否健康，启动时在consul中进行一次注册，这个就是经常说的‘服务注册与发现’中的服务注册，三个服务实例截图如下<br><img src="/images/demomicroserver/serviceRsg.png" srcset="/img/loading.gif" alt="2"><br>注册完成之后打开consul的ui界面可以看到，列表中存在多出一个用户服务的集群组名称：Demo.MicroServer.UserService，如图<br><img src="/images/demomicroserver/consul_main.png" srcset="/img/loading.gif" alt="3"><br>点击Demo.MicroServer.UserService进去之后如图，显示三个服务实例的信息<br><img src="/images/demomicroserver/consul_service_instance_list.png" srcset="/img/loading.gif" alt="4"></p><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p>Swagger提供了一个可视化的UI页面展示描述文件。接口的调用方、测试等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。当然Swagger的功能远不止这些，项目中已经在服务实例中接入swagger，如图<br><img src="/images/demomicroserver/swagger_port_6891.png" srcset="/img/loading.gif" alt="5"><br><img src="/images/demomicroserver/swagger_port_6892.png" srcset="/img/loading.gif" alt="6"><br><img src="/images/demomicroserver/swagger_port_6893.png" srcset="/img/loading.gif" alt="7"><br>因为三个服务实例是同样一份代码，所以可以看到打开三个端口的swagger地址，看到的接口信息完全一致。</p><h2 id="Ocelot-网关"><a href="#Ocelot-网关" class="headerlink" title="Ocelot 网关"></a>Ocelot 网关</h2><p>Ocelot是一个.NET API网关，它提供了路由,请求聚合,服务发现、鉴权、限流熔断、负载均衡器等一系列强大的功能，而这些功能只需要在配置文件中完成即可使用.<br>比如上面的swagger，我们在三个服务实例的端口打开都可以看到api相关文档信息，但是我们能否在api网关中直接集成呢，答案是肯定的，这依赖于ocelot强大的路由功能，如图，简单的几行配置，我们便将swagger配置到了网关当中<br><img src="/images/demomicroserver/ocelot_config_swagger.png" srcset="/img/loading.gif" alt="8"></p><p>网关内置的负载均衡器的使用，如图我在网关中对同一个接口进行了三次调用，可以看到结果分别来自三个不同的端口中，因为我选用了负载均衡器中的轮询策略<br><img src="/images/demomicroserver/ocelot_LoadBalancer_6891.png" srcset="/img/loading.gif" alt="9"><br><img src="/images/demomicroserver/ocelot_LoadBalancer_6892.png" srcset="/img/loading.gif" alt="10"><br><img src="/images/demomicroserver/ocelot_LoadBalancer_6893.png" srcset="/img/loading.gif" alt="11"></p><p>限流策略，当我们配置启用限流策略，并配置单位时间内访问次数限制时，然后快速刷新接口，超过设置的次数限制，那么可以看到按照错误提示出现<br><img src="/images/demomicroserver/ocelot_RateLimit.png" srcset="/img/loading.gif" alt="12"></p><h2 id="Expectationless"><a href="#Expectationless" class="headerlink" title="Expectationless"></a>Expectationless</h2><p>Exceptionless 是一个开源的实时的日志收集框架，相信在微服务架构或者分布式应用应该都离不开一个统一的日志收集功能，Exceptionless就是就很好的提供了服务，相信有很多开发者都在使用ELK来完成日志的收集，这里说下Exceptionless底层也是基于ElasticSearch，<br>Exceptionless提供了两种服务方式，一种是在线的，就是直接在官网注册账户，新建项目，官方会给每个项目分配一个appid，将id配置到项目中即可使用，当然，在线使用是有限制的，对日志收集数量(3000)还有存储时间天数(3天)都有限制，测试或者临时使用应该都没问题，<br>考虑到后面项目会在生产环境中使用，所以我在内网centos上搭建了一个本地化的Exceptionless环境来收集日志。<br>我这里调用一下swagger中写的一个异常收集测试的接口<br><img src="/images/demomicroserver/swagger_exceptionless_collect.png" srcset="/img/loading.gif" alt="13"><br>发送完成后，到Exceptionless的ui界面来查看收集情况<br><img src="/images/demomicroserver/exceptionless_show.png" srcset="/img/loading.gif" alt="14"><br>可以看到界面多出一条发送测试的数据记录</p><h2 id="IdentityServer4统一鉴权中心"><a href="#IdentityServer4统一鉴权中心" class="headerlink" title="IdentityServer4统一鉴权中心"></a>IdentityServer4统一鉴权中心</h2><p>之所有将认证授权放在最后，因为没有这个前面的流程也是可以跑通的，测试的时候如果觉得这部分测试麻烦可以先注释掉，流程跑通后再来集成这个，这个东西的用法还是很多的，这里将IdentityServer4集成到api 网关当中来完成统一的认证鉴权。<br>在identityserver4项目中分别实现以下几个类<br><img src="/images/demomicroserver/identityserver4_starup.png" srcset="/img/loading.gif" alt="15"><br>分类来完全几个东西：定义api资源，客户端访问资源范围，校验账户密码过程和数据返回格式<br>然后在api网关中项目中统一认证，这里需要说明下为什么要将IdentityServer4集成到网关当中而不是在每个服务实例单独去认证，想象一下，如果在一个大型项目中，不同的小组维护着不同的服务实例，势必每个小组都要在各自的代码中完成一套认证逻辑，确实没有必要，<br>而Ocelot天然对IdentityServer4进行了很好的集成，我们只需要在网关中统一添加认证代码即可，而各个微服务实例只需要关心各自的业务逻辑代码即可。<br>这个也列举一下使用过程，在客户端没有token时通过网关对api资源进行访问，可以看到如图的返回状态码：401<br><img src="/images/demomicroserver/401.png" srcset="/img/loading.gif" alt="16"><br>然后我们到IdentityServer4中请求一个token<br><img src="/images/demomicroserver/identityserver4_token.png" srcset="/img/loading.gif" alt="17"><br>拿到token后，带着token再通过网关请求相同的api资源，可以看到正确拿到想要的资源。<br><img src="/images/demomicroserver/identityserver4_bearer_token.png" srcset="/img/loading.gif" alt="18"></p><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p>上面的所有说明，在代码中均有体现，并开放出来，但是对于一个完整的微服务架构来说还是太简略，只是做了简单的说明，后续会具体拆开来分享一下。<br>至于为什么要这么做和工具的安装，博客园等地方有很多这方面的对比和教程可以参考，这里着重关注微服务架构的实现<br><br>欢迎大家提出宝贵意见，当然如果对你有帮助也欢迎star.<br></p><h2 id="后续更新"><a href="#后续更新" class="headerlink" title="后续更新"></a>后续更新</h2><p>后续可能还会加入CAP和APM(已加入)</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>.NetCore</tag>
      
      <tag>Swagger</tag>
      
      <tag>Consul</tag>
      
      <tag>Polly</tag>
      
      <tag>Ocelot</tag>
      
      <tag>IdentityServer4</tag>
      
      <tag>Exceptionless</tag>
      
      <tag>Apollo</tag>
      
      <tag>SkyWalking</tag>
      
      <tag>SkyWalking-dotnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
